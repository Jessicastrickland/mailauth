// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: syncData.proto

#ifndef PROTOBUF_syncData_2eproto__INCLUDED
#define PROTOBUF_syncData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mynigma {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_syncData_2eproto();
void protobuf_AssignDesc_syncData_2eproto();
void protobuf_ShutdownFile_syncData_2eproto();

class privateKey;
class publicKey;
class accountLoginData;
class confidentialAccountData;
class contactDetail;
class syncKeyExpectation;
class syncPrivateKey;
class syncPublicKey;
class syncData;
class deviceDiscoveryData;

// ===================================================================

class privateKey : public ::google::protobuf::Message {
 public:
  privateKey();
  virtual ~privateKey();

  privateKey(const privateKey& from);

  inline privateKey& operator=(const privateKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const privateKey& default_instance();

  void Swap(privateKey* other);

  // implements Message ----------------------------------------------

  privateKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const privateKey& from);
  void MergeFrom(const privateKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encrKeyData = 1;
  inline bool has_encrkeydata() const;
  inline void clear_encrkeydata();
  static const int kEncrKeyDataFieldNumber = 1;
  inline const ::std::string& encrkeydata() const;
  inline void set_encrkeydata(const ::std::string& value);
  inline void set_encrkeydata(const char* value);
  inline void set_encrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_encrkeydata();
  inline ::std::string* release_encrkeydata();
  inline void set_allocated_encrkeydata(::std::string* encrkeydata);

  // required bytes verKeyData = 2;
  inline bool has_verkeydata() const;
  inline void clear_verkeydata();
  static const int kVerKeyDataFieldNumber = 2;
  inline const ::std::string& verkeydata() const;
  inline void set_verkeydata(const ::std::string& value);
  inline void set_verkeydata(const char* value);
  inline void set_verkeydata(const void* value, size_t size);
  inline ::std::string* mutable_verkeydata();
  inline ::std::string* release_verkeydata();
  inline void set_allocated_verkeydata(::std::string* verkeydata);

  // required string keyLabel = 3;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 3;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int32 dateCreated = 4;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 4;
  inline ::google::protobuf::int32 datecreated() const;
  inline void set_datecreated(::google::protobuf::int32 value);

  // optional bool isCompromised = 5;
  inline bool has_iscompromised() const;
  inline void clear_iscompromised();
  static const int kIsCompromisedFieldNumber = 5;
  inline bool iscompromised() const;
  inline void set_iscompromised(bool value);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated string currentReceivedForEmail = 7;
  inline int currentreceivedforemail_size() const;
  inline void clear_currentreceivedforemail();
  static const int kCurrentReceivedForEmailFieldNumber = 7;
  inline const ::std::string& currentreceivedforemail(int index) const;
  inline ::std::string* mutable_currentreceivedforemail(int index);
  inline void set_currentreceivedforemail(int index, const ::std::string& value);
  inline void set_currentreceivedforemail(int index, const char* value);
  inline void set_currentreceivedforemail(int index, const char* value, size_t size);
  inline ::std::string* add_currentreceivedforemail();
  inline void add_currentreceivedforemail(const ::std::string& value);
  inline void add_currentreceivedforemail(const char* value);
  inline void add_currentreceivedforemail(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentreceivedforemail() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentreceivedforemail();

  // repeated string currentSentForEmail = 8;
  inline int currentsentforemail_size() const;
  inline void clear_currentsentforemail();
  static const int kCurrentSentForEmailFieldNumber = 8;
  inline const ::std::string& currentsentforemail(int index) const;
  inline ::std::string* mutable_currentsentforemail(int index);
  inline void set_currentsentforemail(int index, const ::std::string& value);
  inline void set_currentsentforemail(int index, const char* value);
  inline void set_currentsentforemail(int index, const char* value, size_t size);
  inline ::std::string* add_currentsentforemail();
  inline void add_currentsentforemail(const ::std::string& value);
  inline void add_currentsentforemail(const char* value);
  inline void add_currentsentforemail(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentsentforemail() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentsentforemail();

  // optional bytes decrKeyData = 9;
  inline bool has_decrkeydata() const;
  inline void clear_decrkeydata();
  static const int kDecrKeyDataFieldNumber = 9;
  inline const ::std::string& decrkeydata() const;
  inline void set_decrkeydata(const ::std::string& value);
  inline void set_decrkeydata(const char* value);
  inline void set_decrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_decrkeydata();
  inline ::std::string* release_decrkeydata();
  inline void set_allocated_decrkeydata(::std::string* decrkeydata);

  // optional bytes signKeyData = 10;
  inline bool has_signkeydata() const;
  inline void clear_signkeydata();
  static const int kSignKeyDataFieldNumber = 10;
  inline const ::std::string& signkeydata() const;
  inline void set_signkeydata(const ::std::string& value);
  inline void set_signkeydata(const char* value);
  inline void set_signkeydata(const void* value, size_t size);
  inline ::std::string* mutable_signkeydata();
  inline ::std::string* release_signkeydata();
  inline void set_allocated_signkeydata(::std::string* signkeydata);

  // optional string email = 11;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 11;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional bool isCurrent = 12;
  inline bool has_iscurrent() const;
  inline void clear_iscurrent();
  static const int kIsCurrentFieldNumber = 12;
  inline bool iscurrent() const;
  inline void set_iscurrent(bool value);

  // repeated string emailAddresses = 13;
  inline int emailaddresses_size() const;
  inline void clear_emailaddresses();
  static const int kEmailAddressesFieldNumber = 13;
  inline const ::std::string& emailaddresses(int index) const;
  inline ::std::string* mutable_emailaddresses(int index);
  inline void set_emailaddresses(int index, const ::std::string& value);
  inline void set_emailaddresses(int index, const char* value);
  inline void set_emailaddresses(int index, const char* value, size_t size);
  inline ::std::string* add_emailaddresses();
  inline void add_emailaddresses(const ::std::string& value);
  inline void add_emailaddresses(const char* value);
  inline void add_emailaddresses(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& emailaddresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_emailaddresses();

  // @@protoc_insertion_point(class_scope:mynigma.privateKey)
 private:
  inline void set_has_encrkeydata();
  inline void clear_has_encrkeydata();
  inline void set_has_verkeydata();
  inline void clear_has_verkeydata();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();
  inline void set_has_iscompromised();
  inline void clear_has_iscompromised();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_decrkeydata();
  inline void clear_has_decrkeydata();
  inline void set_has_signkeydata();
  inline void clear_has_signkeydata();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_iscurrent();
  inline void clear_has_iscurrent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrkeydata_;
  ::std::string* verkeydata_;
  ::std::string* keylabel_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentreceivedforemail_;
  ::google::protobuf::int32 datecreated_;
  bool iscompromised_;
  bool iscurrent_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentsentforemail_;
  ::std::string* decrkeydata_;
  ::std::string* signkeydata_;
  ::std::string* email_;
  ::google::protobuf::RepeatedPtrField< ::std::string> emailaddresses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static privateKey* default_instance_;
};
// -------------------------------------------------------------------

class publicKey : public ::google::protobuf::Message {
 public:
  publicKey();
  virtual ~publicKey();

  publicKey(const publicKey& from);

  inline publicKey& operator=(const publicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const publicKey& default_instance();

  void Swap(publicKey* other);

  // implements Message ----------------------------------------------

  publicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const publicKey& from);
  void MergeFrom(const publicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encrKeyData = 1;
  inline bool has_encrkeydata() const;
  inline void clear_encrkeydata();
  static const int kEncrKeyDataFieldNumber = 1;
  inline const ::std::string& encrkeydata() const;
  inline void set_encrkeydata(const ::std::string& value);
  inline void set_encrkeydata(const char* value);
  inline void set_encrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_encrkeydata();
  inline ::std::string* release_encrkeydata();
  inline void set_allocated_encrkeydata(::std::string* encrkeydata);

  // required bytes verKeyData = 2;
  inline bool has_verkeydata() const;
  inline void clear_verkeydata();
  static const int kVerKeyDataFieldNumber = 2;
  inline const ::std::string& verkeydata() const;
  inline void set_verkeydata(const ::std::string& value);
  inline void set_verkeydata(const char* value);
  inline void set_verkeydata(const void* value, size_t size);
  inline ::std::string* mutable_verkeydata();
  inline ::std::string* release_verkeydata();
  inline void set_allocated_verkeydata(::std::string* verkeydata);

  // required string keyLabel = 3;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 3;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int32 dateCreated = 4;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 4;
  inline ::google::protobuf::int32 datecreated() const;
  inline void set_datecreated(::google::protobuf::int32 value);

  // optional bool compromised = 5;
  inline bool has_compromised() const;
  inline void clear_compromised();
  static const int kCompromisedFieldNumber = 5;
  inline bool compromised() const;
  inline void set_compromised(bool value);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated string currentKeyForEmail = 7;
  inline int currentkeyforemail_size() const;
  inline void clear_currentkeyforemail();
  static const int kCurrentKeyForEmailFieldNumber = 7;
  inline const ::std::string& currentkeyforemail(int index) const;
  inline ::std::string* mutable_currentkeyforemail(int index);
  inline void set_currentkeyforemail(int index, const ::std::string& value);
  inline void set_currentkeyforemail(int index, const char* value);
  inline void set_currentkeyforemail(int index, const char* value, size_t size);
  inline ::std::string* add_currentkeyforemail();
  inline void add_currentkeyforemail(const ::std::string& value);
  inline void add_currentkeyforemail(const char* value);
  inline void add_currentkeyforemail(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentkeyforemail() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentkeyforemail();

  // optional int32 dateObtained = 8;
  inline bool has_dateobtained() const;
  inline void clear_dateobtained();
  static const int kDateObtainedFieldNumber = 8;
  inline ::google::protobuf::int32 dateobtained() const;
  inline void set_dateobtained(::google::protobuf::int32 value);

  // optional int32 dateDeclared = 9;
  inline bool has_datedeclared() const;
  inline void clear_datedeclared();
  static const int kDateDeclaredFieldNumber = 9;
  inline ::google::protobuf::int32 datedeclared() const;
  inline void set_datedeclared(::google::protobuf::int32 value);

  // optional bool isCompromised = 10;
  inline bool has_iscompromised() const;
  inline void clear_iscompromised();
  static const int kIsCompromisedFieldNumber = 10;
  inline bool iscompromised() const;
  inline void set_iscompromised(bool value);

  // optional bool fromServer = 11;
  inline bool has_fromserver() const;
  inline void clear_fromserver();
  static const int kFromServerFieldNumber = 11;
  inline bool fromserver() const;
  inline void set_fromserver(bool value);

  // repeated string introducesKeys = 12;
  inline int introduceskeys_size() const;
  inline void clear_introduceskeys();
  static const int kIntroducesKeysFieldNumber = 12;
  inline const ::std::string& introduceskeys(int index) const;
  inline ::std::string* mutable_introduceskeys(int index);
  inline void set_introduceskeys(int index, const ::std::string& value);
  inline void set_introduceskeys(int index, const char* value);
  inline void set_introduceskeys(int index, const char* value, size_t size);
  inline ::std::string* add_introduceskeys();
  inline void add_introduceskeys(const ::std::string& value);
  inline void add_introduceskeys(const char* value);
  inline void add_introduceskeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& introduceskeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_introduceskeys();

  // repeated string isIntroducedByKeys = 13;
  inline int isintroducedbykeys_size() const;
  inline void clear_isintroducedbykeys();
  static const int kIsIntroducedByKeysFieldNumber = 13;
  inline const ::std::string& isintroducedbykeys(int index) const;
  inline ::std::string* mutable_isintroducedbykeys(int index);
  inline void set_isintroducedbykeys(int index, const ::std::string& value);
  inline void set_isintroducedbykeys(int index, const char* value);
  inline void set_isintroducedbykeys(int index, const char* value, size_t size);
  inline ::std::string* add_isintroducedbykeys();
  inline void add_isintroducedbykeys(const ::std::string& value);
  inline void add_isintroducedbykeys(const char* value);
  inline void add_isintroducedbykeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& isintroducedbykeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_isintroducedbykeys();

  // optional string email = 14;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 14;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional bool isCurrent = 15;
  inline bool has_iscurrent() const;
  inline void clear_iscurrent();
  static const int kIsCurrentFieldNumber = 15;
  inline bool iscurrent() const;
  inline void set_iscurrent(bool value);

  // @@protoc_insertion_point(class_scope:mynigma.publicKey)
 private:
  inline void set_has_encrkeydata();
  inline void clear_has_encrkeydata();
  inline void set_has_verkeydata();
  inline void clear_has_verkeydata();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();
  inline void set_has_compromised();
  inline void clear_has_compromised();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_dateobtained();
  inline void clear_has_dateobtained();
  inline void set_has_datedeclared();
  inline void clear_has_datedeclared();
  inline void set_has_iscompromised();
  inline void clear_has_iscompromised();
  inline void set_has_fromserver();
  inline void clear_has_fromserver();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_iscurrent();
  inline void clear_has_iscurrent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrkeydata_;
  ::std::string* verkeydata_;
  ::std::string* keylabel_;
  ::std::string* version_;
  ::google::protobuf::int32 datecreated_;
  ::google::protobuf::int32 dateobtained_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentkeyforemail_;
  ::google::protobuf::int32 datedeclared_;
  bool compromised_;
  bool iscompromised_;
  bool fromserver_;
  bool iscurrent_;
  ::google::protobuf::RepeatedPtrField< ::std::string> introduceskeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> isintroducedbykeys_;
  ::std::string* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static publicKey* default_instance_;
};
// -------------------------------------------------------------------

class accountLoginData : public ::google::protobuf::Message {
 public:
  accountLoginData();
  virtual ~accountLoginData();

  accountLoginData(const accountLoginData& from);

  inline accountLoginData& operator=(const accountLoginData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const accountLoginData& default_instance();

  void Swap(accountLoginData* other);

  // implements Message ----------------------------------------------

  accountLoginData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const accountLoginData& from);
  void MergeFrom(const accountLoginData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string inHostname = 1;
  inline bool has_inhostname() const;
  inline void clear_inhostname();
  static const int kInHostnameFieldNumber = 1;
  inline const ::std::string& inhostname() const;
  inline void set_inhostname(const ::std::string& value);
  inline void set_inhostname(const char* value);
  inline void set_inhostname(const char* value, size_t size);
  inline ::std::string* mutable_inhostname();
  inline ::std::string* release_inhostname();
  inline void set_allocated_inhostname(::std::string* inhostname);

  // required string outHostname = 2;
  inline bool has_outhostname() const;
  inline void clear_outhostname();
  static const int kOutHostnameFieldNumber = 2;
  inline const ::std::string& outhostname() const;
  inline void set_outhostname(const ::std::string& value);
  inline void set_outhostname(const char* value);
  inline void set_outhostname(const char* value, size_t size);
  inline ::std::string* mutable_outhostname();
  inline ::std::string* release_outhostname();
  inline void set_allocated_outhostname(::std::string* outhostname);

  // required string inUserName = 3;
  inline bool has_inusername() const;
  inline void clear_inusername();
  static const int kInUserNameFieldNumber = 3;
  inline const ::std::string& inusername() const;
  inline void set_inusername(const ::std::string& value);
  inline void set_inusername(const char* value);
  inline void set_inusername(const char* value, size_t size);
  inline ::std::string* mutable_inusername();
  inline ::std::string* release_inusername();
  inline void set_allocated_inusername(::std::string* inusername);

  // required string outUserName = 4;
  inline bool has_outusername() const;
  inline void clear_outusername();
  static const int kOutUserNameFieldNumber = 4;
  inline const ::std::string& outusername() const;
  inline void set_outusername(const ::std::string& value);
  inline void set_outusername(const char* value);
  inline void set_outusername(const char* value, size_t size);
  inline ::std::string* mutable_outusername();
  inline ::std::string* release_outusername();
  inline void set_allocated_outusername(::std::string* outusername);

  // required string inPassword = 5;
  inline bool has_inpassword() const;
  inline void clear_inpassword();
  static const int kInPasswordFieldNumber = 5;
  inline const ::std::string& inpassword() const;
  inline void set_inpassword(const ::std::string& value);
  inline void set_inpassword(const char* value);
  inline void set_inpassword(const char* value, size_t size);
  inline ::std::string* mutable_inpassword();
  inline ::std::string* release_inpassword();
  inline void set_allocated_inpassword(::std::string* inpassword);

  // required string outPassword = 6;
  inline bool has_outpassword() const;
  inline void clear_outpassword();
  static const int kOutPasswordFieldNumber = 6;
  inline const ::std::string& outpassword() const;
  inline void set_outpassword(const ::std::string& value);
  inline void set_outpassword(const char* value);
  inline void set_outpassword(const char* value, size_t size);
  inline ::std::string* mutable_outpassword();
  inline ::std::string* release_outpassword();
  inline void set_allocated_outpassword(::std::string* outpassword);

  // required int32 inPort = 7;
  inline bool has_inport() const;
  inline void clear_inport();
  static const int kInPortFieldNumber = 7;
  inline ::google::protobuf::int32 inport() const;
  inline void set_inport(::google::protobuf::int32 value);

  // required int32 outPort = 8;
  inline bool has_outport() const;
  inline void clear_outport();
  static const int kOutPortFieldNumber = 8;
  inline ::google::protobuf::int32 outport() const;
  inline void set_outport(::google::protobuf::int32 value);

  // required int32 inEncryption = 9;
  inline bool has_inencryption() const;
  inline void clear_inencryption();
  static const int kInEncryptionFieldNumber = 9;
  inline ::google::protobuf::int32 inencryption() const;
  inline void set_inencryption(::google::protobuf::int32 value);

  // required int32 outEncryption = 10;
  inline bool has_outencryption() const;
  inline void clear_outencryption();
  static const int kOutEncryptionFieldNumber = 10;
  inline ::google::protobuf::int32 outencryption() const;
  inline void set_outencryption(::google::protobuf::int32 value);

  // required int32 inAuthType = 11;
  inline bool has_inauthtype() const;
  inline void clear_inauthtype();
  static const int kInAuthTypeFieldNumber = 11;
  inline ::google::protobuf::int32 inauthtype() const;
  inline void set_inauthtype(::google::protobuf::int32 value);

  // required int32 outAuthType = 12;
  inline bool has_outauthtype() const;
  inline void clear_outauthtype();
  static const int kOutAuthTypeFieldNumber = 12;
  inline ::google::protobuf::int32 outauthtype() const;
  inline void set_outauthtype(::google::protobuf::int32 value);

  // required string email = 13;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 13;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string senderName = 14;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 14;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // optional string senderEmail = 15;
  inline bool has_senderemail() const;
  inline void clear_senderemail();
  static const int kSenderEmailFieldNumber = 15;
  inline const ::std::string& senderemail() const;
  inline void set_senderemail(const ::std::string& value);
  inline void set_senderemail(const char* value);
  inline void set_senderemail(const char* value, size_t size);
  inline ::std::string* mutable_senderemail();
  inline ::std::string* release_senderemail();
  inline void set_allocated_senderemail(::std::string* senderemail);

  // optional string displayName = 16;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 16;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  inline void set_allocated_displayname(::std::string* displayname);

  // optional bool copyIntoSent = 17;
  inline bool has_copyintosent() const;
  inline void clear_copyintosent();
  static const int kCopyIntoSentFieldNumber = 17;
  inline bool copyintosent() const;
  inline void set_copyintosent(bool value);

  // @@protoc_insertion_point(class_scope:mynigma.accountLoginData)
 private:
  inline void set_has_inhostname();
  inline void clear_has_inhostname();
  inline void set_has_outhostname();
  inline void clear_has_outhostname();
  inline void set_has_inusername();
  inline void clear_has_inusername();
  inline void set_has_outusername();
  inline void clear_has_outusername();
  inline void set_has_inpassword();
  inline void clear_has_inpassword();
  inline void set_has_outpassword();
  inline void clear_has_outpassword();
  inline void set_has_inport();
  inline void clear_has_inport();
  inline void set_has_outport();
  inline void clear_has_outport();
  inline void set_has_inencryption();
  inline void clear_has_inencryption();
  inline void set_has_outencryption();
  inline void clear_has_outencryption();
  inline void set_has_inauthtype();
  inline void clear_has_inauthtype();
  inline void set_has_outauthtype();
  inline void clear_has_outauthtype();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_sendername();
  inline void clear_has_sendername();
  inline void set_has_senderemail();
  inline void clear_has_senderemail();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  inline void set_has_copyintosent();
  inline void clear_has_copyintosent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* inhostname_;
  ::std::string* outhostname_;
  ::std::string* inusername_;
  ::std::string* outusername_;
  ::std::string* inpassword_;
  ::std::string* outpassword_;
  ::google::protobuf::int32 inport_;
  ::google::protobuf::int32 outport_;
  ::google::protobuf::int32 inencryption_;
  ::google::protobuf::int32 outencryption_;
  ::google::protobuf::int32 inauthtype_;
  ::google::protobuf::int32 outauthtype_;
  ::std::string* email_;
  ::std::string* sendername_;
  ::std::string* senderemail_;
  ::std::string* displayname_;
  bool copyintosent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static accountLoginData* default_instance_;
};
// -------------------------------------------------------------------

class confidentialAccountData : public ::google::protobuf::Message {
 public:
  confidentialAccountData();
  virtual ~confidentialAccountData();

  confidentialAccountData(const confidentialAccountData& from);

  inline confidentialAccountData& operator=(const confidentialAccountData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const confidentialAccountData& default_instance();

  void Swap(confidentialAccountData* other);

  // implements Message ----------------------------------------------

  confidentialAccountData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const confidentialAccountData& from);
  void MergeFrom(const confidentialAccountData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mynigma.privateKey privKeys = 1;
  inline int privkeys_size() const;
  inline void clear_privkeys();
  static const int kPrivKeysFieldNumber = 1;
  inline const ::mynigma::privateKey& privkeys(int index) const;
  inline ::mynigma::privateKey* mutable_privkeys(int index);
  inline ::mynigma::privateKey* add_privkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >&
      privkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >*
      mutable_privkeys();

  // repeated .mynigma.publicKey pubKeys = 2;
  inline int pubkeys_size() const;
  inline void clear_pubkeys();
  static const int kPubKeysFieldNumber = 2;
  inline const ::mynigma::publicKey& pubkeys(int index) const;
  inline ::mynigma::publicKey* mutable_pubkeys(int index);
  inline ::mynigma::publicKey* add_pubkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >&
      pubkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >*
      mutable_pubkeys();

  // repeated .mynigma.accountLoginData accounts = 3;
  inline int accounts_size() const;
  inline void clear_accounts();
  static const int kAccountsFieldNumber = 3;
  inline const ::mynigma::accountLoginData& accounts(int index) const;
  inline ::mynigma::accountLoginData* mutable_accounts(int index);
  inline ::mynigma::accountLoginData* add_accounts();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >&
      accounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >*
      mutable_accounts();

  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.confidentialAccountData)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey > privkeys_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey > pubkeys_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData > accounts_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static confidentialAccountData* default_instance_;
};
// -------------------------------------------------------------------

class contactDetail : public ::google::protobuf::Message {
 public:
  contactDetail();
  virtual ~contactDetail();

  contactDetail(const contactDetail& from);

  inline contactDetail& operator=(const contactDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const contactDetail& default_instance();

  void Swap(contactDetail* other);

  // implements Message ----------------------------------------------

  contactDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const contactDetail& from);
  void MergeFrom(const contactDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string firstName = 1;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstNameFieldNumber = 1;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string lastName = 2;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastNameFieldNumber = 2;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string emailAddress = 3;
  inline bool has_emailaddress() const;
  inline void clear_emailaddress();
  static const int kEmailAddressFieldNumber = 3;
  inline const ::std::string& emailaddress() const;
  inline void set_emailaddress(const ::std::string& value);
  inline void set_emailaddress(const char* value);
  inline void set_emailaddress(const char* value, size_t size);
  inline ::std::string* mutable_emailaddress();
  inline ::std::string* release_emailaddress();
  inline void set_allocated_emailaddress(::std::string* emailaddress);

  // optional string currentSentKey = 4;
  inline bool has_currentsentkey() const;
  inline void clear_currentsentkey();
  static const int kCurrentSentKeyFieldNumber = 4;
  inline const ::std::string& currentsentkey() const;
  inline void set_currentsentkey(const ::std::string& value);
  inline void set_currentsentkey(const char* value);
  inline void set_currentsentkey(const char* value, size_t size);
  inline ::std::string* mutable_currentsentkey();
  inline ::std::string* release_currentsentkey();
  inline void set_allocated_currentsentkey(::std::string* currentsentkey);

  // optional int32 dateSentKey = 5;
  inline bool has_datesentkey() const;
  inline void clear_datesentkey();
  static const int kDateSentKeyFieldNumber = 5;
  inline ::google::protobuf::int32 datesentkey() const;
  inline void set_datesentkey(::google::protobuf::int32 value);

  // optional string currentReceivedKey = 6;
  inline bool has_currentreceivedkey() const;
  inline void clear_currentreceivedkey();
  static const int kCurrentReceivedKeyFieldNumber = 6;
  inline const ::std::string& currentreceivedkey() const;
  inline void set_currentreceivedkey(const ::std::string& value);
  inline void set_currentreceivedkey(const char* value);
  inline void set_currentreceivedkey(const char* value, size_t size);
  inline ::std::string* mutable_currentreceivedkey();
  inline ::std::string* release_currentreceivedkey();
  inline void set_allocated_currentreceivedkey(::std::string* currentreceivedkey);

  // optional int32 dateReceivedKey = 7;
  inline bool has_datereceivedkey() const;
  inline void clear_datereceivedkey();
  static const int kDateReceivedKeyFieldNumber = 7;
  inline ::google::protobuf::int32 datereceivedkey() const;
  inline void set_datereceivedkey(::google::protobuf::int32 value);

  // optional int32 numberOfTimesContacted = 8;
  inline bool has_numberoftimescontacted() const;
  inline void clear_numberoftimescontacted();
  static const int kNumberOfTimesContactedFieldNumber = 8;
  inline ::google::protobuf::int32 numberoftimescontacted() const;
  inline void set_numberoftimescontacted(::google::protobuf::int32 value);

  // optional int32 lastCheckedWithServer = 9;
  inline bool has_lastcheckedwithserver() const;
  inline void clear_lastcheckedwithserver();
  static const int kLastCheckedWithServerFieldNumber = 9;
  inline ::google::protobuf::int32 lastcheckedwithserver() const;
  inline void set_lastcheckedwithserver(::google::protobuf::int32 value);

  // optional string fullName = 10;
  inline bool has_fullname() const;
  inline void clear_fullname();
  static const int kFullNameFieldNumber = 10;
  inline const ::std::string& fullname() const;
  inline void set_fullname(const ::std::string& value);
  inline void set_fullname(const char* value);
  inline void set_fullname(const char* value, size_t size);
  inline ::std::string* mutable_fullname();
  inline ::std::string* release_fullname();
  inline void set_allocated_fullname(::std::string* fullname);

  // optional int32 lastInfoChange = 11;
  inline bool has_lastinfochange() const;
  inline void clear_lastinfochange();
  static const int kLastInfoChangeFieldNumber = 11;
  inline ::google::protobuf::int32 lastinfochange() const;
  inline void set_lastinfochange(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mynigma.contactDetail)
 private:
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_emailaddress();
  inline void clear_has_emailaddress();
  inline void set_has_currentsentkey();
  inline void clear_has_currentsentkey();
  inline void set_has_datesentkey();
  inline void clear_has_datesentkey();
  inline void set_has_currentreceivedkey();
  inline void clear_has_currentreceivedkey();
  inline void set_has_datereceivedkey();
  inline void clear_has_datereceivedkey();
  inline void set_has_numberoftimescontacted();
  inline void clear_has_numberoftimescontacted();
  inline void set_has_lastcheckedwithserver();
  inline void clear_has_lastcheckedwithserver();
  inline void set_has_fullname();
  inline void clear_has_fullname();
  inline void set_has_lastinfochange();
  inline void clear_has_lastinfochange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* firstname_;
  ::std::string* lastname_;
  ::std::string* emailaddress_;
  ::std::string* currentsentkey_;
  ::std::string* currentreceivedkey_;
  ::google::protobuf::int32 datesentkey_;
  ::google::protobuf::int32 datereceivedkey_;
  ::google::protobuf::int32 numberoftimescontacted_;
  ::google::protobuf::int32 lastcheckedwithserver_;
  ::std::string* fullname_;
  ::google::protobuf::int32 lastinfochange_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static contactDetail* default_instance_;
};
// -------------------------------------------------------------------

class syncKeyExpectation : public ::google::protobuf::Message {
 public:
  syncKeyExpectation();
  virtual ~syncKeyExpectation();

  syncKeyExpectation(const syncKeyExpectation& from);

  inline syncKeyExpectation& operator=(const syncKeyExpectation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syncKeyExpectation& default_instance();

  void Swap(syncKeyExpectation* other);

  // implements Message ----------------------------------------------

  syncKeyExpectation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syncKeyExpectation& from);
  void MergeFrom(const syncKeyExpectation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fromAddress = 1;
  inline bool has_fromaddress() const;
  inline void clear_fromaddress();
  static const int kFromAddressFieldNumber = 1;
  inline const ::std::string& fromaddress() const;
  inline void set_fromaddress(const ::std::string& value);
  inline void set_fromaddress(const char* value);
  inline void set_fromaddress(const char* value, size_t size);
  inline ::std::string* mutable_fromaddress();
  inline ::std::string* release_fromaddress();
  inline void set_allocated_fromaddress(::std::string* fromaddress);

  // optional string toAddress = 2;
  inline bool has_toaddress() const;
  inline void clear_toaddress();
  static const int kToAddressFieldNumber = 2;
  inline const ::std::string& toaddress() const;
  inline void set_toaddress(const ::std::string& value);
  inline void set_toaddress(const char* value);
  inline void set_toaddress(const char* value, size_t size);
  inline ::std::string* mutable_toaddress();
  inline ::std::string* release_toaddress();
  inline void set_allocated_toaddress(::std::string* toaddress);

  // optional string keyLabel = 3;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 3;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int32 dateAnchored = 4;
  inline bool has_dateanchored() const;
  inline void clear_dateanchored();
  static const int kDateAnchoredFieldNumber = 4;
  inline ::google::protobuf::int32 dateanchored() const;
  inline void set_dateanchored(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mynigma.syncKeyExpectation)
 private:
  inline void set_has_fromaddress();
  inline void clear_has_fromaddress();
  inline void set_has_toaddress();
  inline void clear_has_toaddress();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_dateanchored();
  inline void clear_has_dateanchored();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fromaddress_;
  ::std::string* toaddress_;
  ::std::string* keylabel_;
  ::google::protobuf::int32 dateanchored_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static syncKeyExpectation* default_instance_;
};
// -------------------------------------------------------------------

class syncPrivateKey : public ::google::protobuf::Message {
 public:
  syncPrivateKey();
  virtual ~syncPrivateKey();

  syncPrivateKey(const syncPrivateKey& from);

  inline syncPrivateKey& operator=(const syncPrivateKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syncPrivateKey& default_instance();

  void Swap(syncPrivateKey* other);

  // implements Message ----------------------------------------------

  syncPrivateKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syncPrivateKey& from);
  void MergeFrom(const syncPrivateKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encrKeyData = 1;
  inline bool has_encrkeydata() const;
  inline void clear_encrkeydata();
  static const int kEncrKeyDataFieldNumber = 1;
  inline const ::std::string& encrkeydata() const;
  inline void set_encrkeydata(const ::std::string& value);
  inline void set_encrkeydata(const char* value);
  inline void set_encrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_encrkeydata();
  inline ::std::string* release_encrkeydata();
  inline void set_allocated_encrkeydata(::std::string* encrkeydata);

  // required bytes verKeyData = 2;
  inline bool has_verkeydata() const;
  inline void clear_verkeydata();
  static const int kVerKeyDataFieldNumber = 2;
  inline const ::std::string& verkeydata() const;
  inline void set_verkeydata(const ::std::string& value);
  inline void set_verkeydata(const char* value);
  inline void set_verkeydata(const void* value, size_t size);
  inline ::std::string* mutable_verkeydata();
  inline ::std::string* release_verkeydata();
  inline void set_allocated_verkeydata(::std::string* verkeydata);

  // required string keyLabel = 3;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 3;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int32 dateCreated = 4;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 4;
  inline ::google::protobuf::int32 datecreated() const;
  inline void set_datecreated(::google::protobuf::int32 value);

  // optional bool isCompromised = 5;
  inline bool has_iscompromised() const;
  inline void clear_iscompromised();
  static const int kIsCompromisedFieldNumber = 5;
  inline bool iscompromised() const;
  inline void set_iscompromised(bool value);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated string currentKeyForEmail = 7;
  inline int currentkeyforemail_size() const;
  inline void clear_currentkeyforemail();
  static const int kCurrentKeyForEmailFieldNumber = 7;
  inline const ::std::string& currentkeyforemail(int index) const;
  inline ::std::string* mutable_currentkeyforemail(int index);
  inline void set_currentkeyforemail(int index, const ::std::string& value);
  inline void set_currentkeyforemail(int index, const char* value);
  inline void set_currentkeyforemail(int index, const char* value, size_t size);
  inline ::std::string* add_currentkeyforemail();
  inline void add_currentkeyforemail(const ::std::string& value);
  inline void add_currentkeyforemail(const char* value);
  inline void add_currentkeyforemail(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentkeyforemail() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentkeyforemail();

  // optional int32 dateObtained = 8;
  inline bool has_dateobtained() const;
  inline void clear_dateobtained();
  static const int kDateObtainedFieldNumber = 8;
  inline ::google::protobuf::int32 dateobtained() const;
  inline void set_dateobtained(::google::protobuf::int32 value);

  // optional int32 dateDeclared = 9;
  inline bool has_datedeclared() const;
  inline void clear_datedeclared();
  static const int kDateDeclaredFieldNumber = 9;
  inline ::google::protobuf::int32 datedeclared() const;
  inline void set_datedeclared(::google::protobuf::int32 value);

  // optional int32 dateFirstAnchored = 10;
  inline bool has_datefirstanchored() const;
  inline void clear_datefirstanchored();
  static const int kDateFirstAnchoredFieldNumber = 10;
  inline ::google::protobuf::int32 datefirstanchored() const;
  inline void set_datefirstanchored(::google::protobuf::int32 value);

  // optional bool fromServer = 11;
  inline bool has_fromserver() const;
  inline void clear_fromserver();
  static const int kFromServerFieldNumber = 11;
  inline bool fromserver() const;
  inline void set_fromserver(bool value);

  // repeated string introducesKeys = 12;
  inline int introduceskeys_size() const;
  inline void clear_introduceskeys();
  static const int kIntroducesKeysFieldNumber = 12;
  inline const ::std::string& introduceskeys(int index) const;
  inline ::std::string* mutable_introduceskeys(int index);
  inline void set_introduceskeys(int index, const ::std::string& value);
  inline void set_introduceskeys(int index, const char* value);
  inline void set_introduceskeys(int index, const char* value, size_t size);
  inline ::std::string* add_introduceskeys();
  inline void add_introduceskeys(const ::std::string& value);
  inline void add_introduceskeys(const char* value);
  inline void add_introduceskeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& introduceskeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_introduceskeys();

  // repeated string isIntroducedByKeys = 13;
  inline int isintroducedbykeys_size() const;
  inline void clear_isintroducedbykeys();
  static const int kIsIntroducedByKeysFieldNumber = 13;
  inline const ::std::string& isintroducedbykeys(int index) const;
  inline ::std::string* mutable_isintroducedbykeys(int index);
  inline void set_isintroducedbykeys(int index, const ::std::string& value);
  inline void set_isintroducedbykeys(int index, const char* value);
  inline void set_isintroducedbykeys(int index, const char* value, size_t size);
  inline ::std::string* add_isintroducedbykeys();
  inline void add_isintroducedbykeys(const ::std::string& value);
  inline void add_isintroducedbykeys(const char* value);
  inline void add_isintroducedbykeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& isintroducedbykeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_isintroducedbykeys();

  // repeated string emailAddresses = 14;
  inline int emailaddresses_size() const;
  inline void clear_emailaddresses();
  static const int kEmailAddressesFieldNumber = 14;
  inline const ::std::string& emailaddresses(int index) const;
  inline ::std::string* mutable_emailaddresses(int index);
  inline void set_emailaddresses(int index, const ::std::string& value);
  inline void set_emailaddresses(int index, const char* value);
  inline void set_emailaddresses(int index, const char* value, size_t size);
  inline ::std::string* add_emailaddresses();
  inline void add_emailaddresses(const ::std::string& value);
  inline void add_emailaddresses(const char* value);
  inline void add_emailaddresses(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& emailaddresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_emailaddresses();

  // optional bytes decrKeyData = 15;
  inline bool has_decrkeydata() const;
  inline void clear_decrkeydata();
  static const int kDecrKeyDataFieldNumber = 15;
  inline const ::std::string& decrkeydata() const;
  inline void set_decrkeydata(const ::std::string& value);
  inline void set_decrkeydata(const char* value);
  inline void set_decrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_decrkeydata();
  inline ::std::string* release_decrkeydata();
  inline void set_allocated_decrkeydata(::std::string* decrkeydata);

  // optional bytes signKeyData = 16;
  inline bool has_signkeydata() const;
  inline void clear_signkeydata();
  static const int kSignKeyDataFieldNumber = 16;
  inline const ::std::string& signkeydata() const;
  inline void set_signkeydata(const ::std::string& value);
  inline void set_signkeydata(const char* value);
  inline void set_signkeydata(const void* value, size_t size);
  inline ::std::string* mutable_signkeydata();
  inline ::std::string* release_signkeydata();
  inline void set_allocated_signkeydata(::std::string* signkeydata);

  // @@protoc_insertion_point(class_scope:mynigma.syncPrivateKey)
 private:
  inline void set_has_encrkeydata();
  inline void clear_has_encrkeydata();
  inline void set_has_verkeydata();
  inline void clear_has_verkeydata();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();
  inline void set_has_iscompromised();
  inline void clear_has_iscompromised();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_dateobtained();
  inline void clear_has_dateobtained();
  inline void set_has_datedeclared();
  inline void clear_has_datedeclared();
  inline void set_has_datefirstanchored();
  inline void clear_has_datefirstanchored();
  inline void set_has_fromserver();
  inline void clear_has_fromserver();
  inline void set_has_decrkeydata();
  inline void clear_has_decrkeydata();
  inline void set_has_signkeydata();
  inline void clear_has_signkeydata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrkeydata_;
  ::std::string* verkeydata_;
  ::std::string* keylabel_;
  ::std::string* version_;
  ::google::protobuf::int32 datecreated_;
  ::google::protobuf::int32 dateobtained_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentkeyforemail_;
  bool iscompromised_;
  bool fromserver_;
  ::google::protobuf::int32 datedeclared_;
  ::google::protobuf::RepeatedPtrField< ::std::string> introduceskeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> isintroducedbykeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> emailaddresses_;
  ::std::string* decrkeydata_;
  ::std::string* signkeydata_;
  ::google::protobuf::int32 datefirstanchored_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static syncPrivateKey* default_instance_;
};
// -------------------------------------------------------------------

class syncPublicKey : public ::google::protobuf::Message {
 public:
  syncPublicKey();
  virtual ~syncPublicKey();

  syncPublicKey(const syncPublicKey& from);

  inline syncPublicKey& operator=(const syncPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syncPublicKey& default_instance();

  void Swap(syncPublicKey* other);

  // implements Message ----------------------------------------------

  syncPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syncPublicKey& from);
  void MergeFrom(const syncPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes encrKeyData = 1;
  inline bool has_encrkeydata() const;
  inline void clear_encrkeydata();
  static const int kEncrKeyDataFieldNumber = 1;
  inline const ::std::string& encrkeydata() const;
  inline void set_encrkeydata(const ::std::string& value);
  inline void set_encrkeydata(const char* value);
  inline void set_encrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_encrkeydata();
  inline ::std::string* release_encrkeydata();
  inline void set_allocated_encrkeydata(::std::string* encrkeydata);

  // required bytes verKeyData = 2;
  inline bool has_verkeydata() const;
  inline void clear_verkeydata();
  static const int kVerKeyDataFieldNumber = 2;
  inline const ::std::string& verkeydata() const;
  inline void set_verkeydata(const ::std::string& value);
  inline void set_verkeydata(const char* value);
  inline void set_verkeydata(const void* value, size_t size);
  inline ::std::string* mutable_verkeydata();
  inline ::std::string* release_verkeydata();
  inline void set_allocated_verkeydata(::std::string* verkeydata);

  // required string keyLabel = 3;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 3;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int32 dateCreated = 4;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 4;
  inline ::google::protobuf::int32 datecreated() const;
  inline void set_datecreated(::google::protobuf::int32 value);

  // optional bool compromised = 5;
  inline bool has_compromised() const;
  inline void clear_compromised();
  static const int kCompromisedFieldNumber = 5;
  inline bool compromised() const;
  inline void set_compromised(bool value);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated string currentKeyForEmail = 7;
  inline int currentkeyforemail_size() const;
  inline void clear_currentkeyforemail();
  static const int kCurrentKeyForEmailFieldNumber = 7;
  inline const ::std::string& currentkeyforemail(int index) const;
  inline ::std::string* mutable_currentkeyforemail(int index);
  inline void set_currentkeyforemail(int index, const ::std::string& value);
  inline void set_currentkeyforemail(int index, const char* value);
  inline void set_currentkeyforemail(int index, const char* value, size_t size);
  inline ::std::string* add_currentkeyforemail();
  inline void add_currentkeyforemail(const ::std::string& value);
  inline void add_currentkeyforemail(const char* value);
  inline void add_currentkeyforemail(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentkeyforemail() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentkeyforemail();

  // optional int32 dateObtained = 8;
  inline bool has_dateobtained() const;
  inline void clear_dateobtained();
  static const int kDateObtainedFieldNumber = 8;
  inline ::google::protobuf::int32 dateobtained() const;
  inline void set_dateobtained(::google::protobuf::int32 value);

  // optional int32 dateDeclared = 9;
  inline bool has_datedeclared() const;
  inline void clear_datedeclared();
  static const int kDateDeclaredFieldNumber = 9;
  inline ::google::protobuf::int32 datedeclared() const;
  inline void set_datedeclared(::google::protobuf::int32 value);

  // optional int32 dateFirstAnchored = 10;
  inline bool has_datefirstanchored() const;
  inline void clear_datefirstanchored();
  static const int kDateFirstAnchoredFieldNumber = 10;
  inline ::google::protobuf::int32 datefirstanchored() const;
  inline void set_datefirstanchored(::google::protobuf::int32 value);

  // optional bool fromServer = 11;
  inline bool has_fromserver() const;
  inline void clear_fromserver();
  static const int kFromServerFieldNumber = 11;
  inline bool fromserver() const;
  inline void set_fromserver(bool value);

  // repeated string introducesKeys = 12;
  inline int introduceskeys_size() const;
  inline void clear_introduceskeys();
  static const int kIntroducesKeysFieldNumber = 12;
  inline const ::std::string& introduceskeys(int index) const;
  inline ::std::string* mutable_introduceskeys(int index);
  inline void set_introduceskeys(int index, const ::std::string& value);
  inline void set_introduceskeys(int index, const char* value);
  inline void set_introduceskeys(int index, const char* value, size_t size);
  inline ::std::string* add_introduceskeys();
  inline void add_introduceskeys(const ::std::string& value);
  inline void add_introduceskeys(const char* value);
  inline void add_introduceskeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& introduceskeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_introduceskeys();

  // repeated string isIntroducedByKeys = 13;
  inline int isintroducedbykeys_size() const;
  inline void clear_isintroducedbykeys();
  static const int kIsIntroducedByKeysFieldNumber = 13;
  inline const ::std::string& isintroducedbykeys(int index) const;
  inline ::std::string* mutable_isintroducedbykeys(int index);
  inline void set_isintroducedbykeys(int index, const ::std::string& value);
  inline void set_isintroducedbykeys(int index, const char* value);
  inline void set_isintroducedbykeys(int index, const char* value, size_t size);
  inline ::std::string* add_isintroducedbykeys();
  inline void add_isintroducedbykeys(const ::std::string& value);
  inline void add_isintroducedbykeys(const char* value);
  inline void add_isintroducedbykeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& isintroducedbykeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_isintroducedbykeys();

  // repeated string emailAddresses = 14;
  inline int emailaddresses_size() const;
  inline void clear_emailaddresses();
  static const int kEmailAddressesFieldNumber = 14;
  inline const ::std::string& emailaddresses(int index) const;
  inline ::std::string* mutable_emailaddresses(int index);
  inline void set_emailaddresses(int index, const ::std::string& value);
  inline void set_emailaddresses(int index, const char* value);
  inline void set_emailaddresses(int index, const char* value, size_t size);
  inline ::std::string* add_emailaddresses();
  inline void add_emailaddresses(const ::std::string& value);
  inline void add_emailaddresses(const char* value);
  inline void add_emailaddresses(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& emailaddresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_emailaddresses();

  // @@protoc_insertion_point(class_scope:mynigma.syncPublicKey)
 private:
  inline void set_has_encrkeydata();
  inline void clear_has_encrkeydata();
  inline void set_has_verkeydata();
  inline void clear_has_verkeydata();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();
  inline void set_has_compromised();
  inline void clear_has_compromised();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_dateobtained();
  inline void clear_has_dateobtained();
  inline void set_has_datedeclared();
  inline void clear_has_datedeclared();
  inline void set_has_datefirstanchored();
  inline void clear_has_datefirstanchored();
  inline void set_has_fromserver();
  inline void clear_has_fromserver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrkeydata_;
  ::std::string* verkeydata_;
  ::std::string* keylabel_;
  ::std::string* version_;
  ::google::protobuf::int32 datecreated_;
  ::google::protobuf::int32 dateobtained_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentkeyforemail_;
  bool compromised_;
  bool fromserver_;
  ::google::protobuf::int32 datedeclared_;
  ::google::protobuf::RepeatedPtrField< ::std::string> introduceskeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> isintroducedbykeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> emailaddresses_;
  ::google::protobuf::int32 datefirstanchored_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static syncPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class syncData : public ::google::protobuf::Message {
 public:
  syncData();
  virtual ~syncData();

  syncData(const syncData& from);

  inline syncData& operator=(const syncData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syncData& default_instance();

  void Swap(syncData* other);

  // implements Message ----------------------------------------------

  syncData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syncData& from);
  void MergeFrom(const syncData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mynigma.syncPrivateKey privKeys = 1;
  inline int privkeys_size() const;
  inline void clear_privkeys();
  static const int kPrivKeysFieldNumber = 1;
  inline const ::mynigma::syncPrivateKey& privkeys(int index) const;
  inline ::mynigma::syncPrivateKey* mutable_privkeys(int index);
  inline ::mynigma::syncPrivateKey* add_privkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::syncPrivateKey >&
      privkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::syncPrivateKey >*
      mutable_privkeys();

  // repeated .mynigma.syncPublicKey pubKeys = 2;
  inline int pubkeys_size() const;
  inline void clear_pubkeys();
  static const int kPubKeysFieldNumber = 2;
  inline const ::mynigma::syncPublicKey& pubkeys(int index) const;
  inline ::mynigma::syncPublicKey* mutable_pubkeys(int index);
  inline ::mynigma::syncPublicKey* add_pubkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::syncPublicKey >&
      pubkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::syncPublicKey >*
      mutable_pubkeys();

  // repeated .mynigma.accountLoginData accounts = 3;
  inline int accounts_size() const;
  inline void clear_accounts();
  static const int kAccountsFieldNumber = 3;
  inline const ::mynigma::accountLoginData& accounts(int index) const;
  inline ::mynigma::accountLoginData* mutable_accounts(int index);
  inline ::mynigma::accountLoginData* add_accounts();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >&
      accounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >*
      mutable_accounts();

  // repeated .mynigma.contactDetail contacts = 4;
  inline int contacts_size() const;
  inline void clear_contacts();
  static const int kContactsFieldNumber = 4;
  inline const ::mynigma::contactDetail& contacts(int index) const;
  inline ::mynigma::contactDetail* mutable_contacts(int index);
  inline ::mynigma::contactDetail* add_contacts();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::contactDetail >&
      contacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::contactDetail >*
      mutable_contacts();

  // repeated .mynigma.syncKeyExpectation keyExpectations = 5;
  inline int keyexpectations_size() const;
  inline void clear_keyexpectations();
  static const int kKeyExpectationsFieldNumber = 5;
  inline const ::mynigma::syncKeyExpectation& keyexpectations(int index) const;
  inline ::mynigma::syncKeyExpectation* mutable_keyexpectations(int index);
  inline ::mynigma::syncKeyExpectation* add_keyexpectations();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::syncKeyExpectation >&
      keyexpectations() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::syncKeyExpectation >*
      mutable_keyexpectations();

  // @@protoc_insertion_point(class_scope:mynigma.syncData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mynigma::syncPrivateKey > privkeys_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::syncPublicKey > pubkeys_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData > accounts_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::contactDetail > contacts_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::syncKeyExpectation > keyexpectations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static syncData* default_instance_;
};
// -------------------------------------------------------------------

class deviceDiscoveryData : public ::google::protobuf::Message {
 public:
  deviceDiscoveryData();
  virtual ~deviceDiscoveryData();

  deviceDiscoveryData(const deviceDiscoveryData& from);

  inline deviceDiscoveryData& operator=(const deviceDiscoveryData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const deviceDiscoveryData& default_instance();

  void Swap(deviceDiscoveryData* other);

  // implements Message ----------------------------------------------

  deviceDiscoveryData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const deviceDiscoveryData& from);
  void MergeFrom(const deviceDiscoveryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUUIDFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string emailAdresses = 4;
  inline int emailadresses_size() const;
  inline void clear_emailadresses();
  static const int kEmailAdressesFieldNumber = 4;
  inline const ::std::string& emailadresses(int index) const;
  inline ::std::string* mutable_emailadresses(int index);
  inline void set_emailadresses(int index, const ::std::string& value);
  inline void set_emailadresses(int index, const char* value);
  inline void set_emailadresses(int index, const char* value, size_t size);
  inline ::std::string* add_emailadresses();
  inline void add_emailadresses(const ::std::string& value);
  inline void add_emailadresses(const char* value);
  inline void add_emailadresses(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& emailadresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_emailadresses();

  // repeated string privateKeyLabels = 5;
  inline int privatekeylabels_size() const;
  inline void clear_privatekeylabels();
  static const int kPrivateKeyLabelsFieldNumber = 5;
  inline const ::std::string& privatekeylabels(int index) const;
  inline ::std::string* mutable_privatekeylabels(int index);
  inline void set_privatekeylabels(int index, const ::std::string& value);
  inline void set_privatekeylabels(int index, const char* value);
  inline void set_privatekeylabels(int index, const char* value, size_t size);
  inline ::std::string* add_privatekeylabels();
  inline void add_privatekeylabels(const ::std::string& value);
  inline void add_privatekeylabels(const char* value);
  inline void add_privatekeylabels(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& privatekeylabels() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_privatekeylabels();

  // @@protoc_insertion_point(class_scope:mynigma.deviceDiscoveryData)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* type_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> emailadresses_;
  ::google::protobuf::RepeatedPtrField< ::std::string> privatekeylabels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_syncData_2eproto();
  friend void protobuf_AssignDesc_syncData_2eproto();
  friend void protobuf_ShutdownFile_syncData_2eproto();

  void InitAsDefaultInstance();
  static deviceDiscoveryData* default_instance_;
};
// ===================================================================


// ===================================================================

// privateKey

// required bytes encrKeyData = 1;
inline bool privateKey::has_encrkeydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void privateKey::set_has_encrkeydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void privateKey::clear_has_encrkeydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void privateKey::clear_encrkeydata() {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    encrkeydata_->clear();
  }
  clear_has_encrkeydata();
}
inline const ::std::string& privateKey::encrkeydata() const {
  return *encrkeydata_;
}
inline void privateKey::set_encrkeydata(const ::std::string& value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void privateKey::set_encrkeydata(const char* value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void privateKey::set_encrkeydata(const void* value, size_t size) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_encrkeydata() {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  return encrkeydata_;
}
inline ::std::string* privateKey::release_encrkeydata() {
  clear_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrkeydata_;
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_encrkeydata(::std::string* encrkeydata) {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrkeydata_;
  }
  if (encrkeydata) {
    set_has_encrkeydata();
    encrkeydata_ = encrkeydata;
  } else {
    clear_has_encrkeydata();
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes verKeyData = 2;
inline bool privateKey::has_verkeydata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void privateKey::set_has_verkeydata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void privateKey::clear_has_verkeydata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void privateKey::clear_verkeydata() {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    verkeydata_->clear();
  }
  clear_has_verkeydata();
}
inline const ::std::string& privateKey::verkeydata() const {
  return *verkeydata_;
}
inline void privateKey::set_verkeydata(const ::std::string& value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void privateKey::set_verkeydata(const char* value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void privateKey::set_verkeydata(const void* value, size_t size) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_verkeydata() {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  return verkeydata_;
}
inline ::std::string* privateKey::release_verkeydata() {
  clear_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verkeydata_;
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_verkeydata(::std::string* verkeydata) {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete verkeydata_;
  }
  if (verkeydata) {
    set_has_verkeydata();
    verkeydata_ = verkeydata;
  } else {
    clear_has_verkeydata();
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string keyLabel = 3;
inline bool privateKey::has_keylabel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void privateKey::set_has_keylabel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void privateKey::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void privateKey::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& privateKey::keylabel() const {
  return *keylabel_;
}
inline void privateKey::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void privateKey::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void privateKey::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* privateKey::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateCreated = 4;
inline bool privateKey::has_datecreated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void privateKey::set_has_datecreated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void privateKey::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void privateKey::clear_datecreated() {
  datecreated_ = 0;
  clear_has_datecreated();
}
inline ::google::protobuf::int32 privateKey::datecreated() const {
  return datecreated_;
}
inline void privateKey::set_datecreated(::google::protobuf::int32 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// optional bool isCompromised = 5;
inline bool privateKey::has_iscompromised() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void privateKey::set_has_iscompromised() {
  _has_bits_[0] |= 0x00000010u;
}
inline void privateKey::clear_has_iscompromised() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void privateKey::clear_iscompromised() {
  iscompromised_ = false;
  clear_has_iscompromised();
}
inline bool privateKey::iscompromised() const {
  return iscompromised_;
}
inline void privateKey::set_iscompromised(bool value) {
  set_has_iscompromised();
  iscompromised_ = value;
}

// optional string version = 6;
inline bool privateKey::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void privateKey::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void privateKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void privateKey::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& privateKey::version() const {
  return *version_;
}
inline void privateKey::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void privateKey::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void privateKey::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* privateKey::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string currentReceivedForEmail = 7;
inline int privateKey::currentreceivedforemail_size() const {
  return currentreceivedforemail_.size();
}
inline void privateKey::clear_currentreceivedforemail() {
  currentreceivedforemail_.Clear();
}
inline const ::std::string& privateKey::currentreceivedforemail(int index) const {
  return currentreceivedforemail_.Get(index);
}
inline ::std::string* privateKey::mutable_currentreceivedforemail(int index) {
  return currentreceivedforemail_.Mutable(index);
}
inline void privateKey::set_currentreceivedforemail(int index, const ::std::string& value) {
  currentreceivedforemail_.Mutable(index)->assign(value);
}
inline void privateKey::set_currentreceivedforemail(int index, const char* value) {
  currentreceivedforemail_.Mutable(index)->assign(value);
}
inline void privateKey::set_currentreceivedforemail(int index, const char* value, size_t size) {
  currentreceivedforemail_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_currentreceivedforemail() {
  return currentreceivedforemail_.Add();
}
inline void privateKey::add_currentreceivedforemail(const ::std::string& value) {
  currentreceivedforemail_.Add()->assign(value);
}
inline void privateKey::add_currentreceivedforemail(const char* value) {
  currentreceivedforemail_.Add()->assign(value);
}
inline void privateKey::add_currentreceivedforemail(const char* value, size_t size) {
  currentreceivedforemail_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::currentreceivedforemail() const {
  return currentreceivedforemail_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_currentreceivedforemail() {
  return &currentreceivedforemail_;
}

// repeated string currentSentForEmail = 8;
inline int privateKey::currentsentforemail_size() const {
  return currentsentforemail_.size();
}
inline void privateKey::clear_currentsentforemail() {
  currentsentforemail_.Clear();
}
inline const ::std::string& privateKey::currentsentforemail(int index) const {
  return currentsentforemail_.Get(index);
}
inline ::std::string* privateKey::mutable_currentsentforemail(int index) {
  return currentsentforemail_.Mutable(index);
}
inline void privateKey::set_currentsentforemail(int index, const ::std::string& value) {
  currentsentforemail_.Mutable(index)->assign(value);
}
inline void privateKey::set_currentsentforemail(int index, const char* value) {
  currentsentforemail_.Mutable(index)->assign(value);
}
inline void privateKey::set_currentsentforemail(int index, const char* value, size_t size) {
  currentsentforemail_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_currentsentforemail() {
  return currentsentforemail_.Add();
}
inline void privateKey::add_currentsentforemail(const ::std::string& value) {
  currentsentforemail_.Add()->assign(value);
}
inline void privateKey::add_currentsentforemail(const char* value) {
  currentsentforemail_.Add()->assign(value);
}
inline void privateKey::add_currentsentforemail(const char* value, size_t size) {
  currentsentforemail_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::currentsentforemail() const {
  return currentsentforemail_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_currentsentforemail() {
  return &currentsentforemail_;
}

// optional bytes decrKeyData = 9;
inline bool privateKey::has_decrkeydata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void privateKey::set_has_decrkeydata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void privateKey::clear_has_decrkeydata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void privateKey::clear_decrkeydata() {
  if (decrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    decrkeydata_->clear();
  }
  clear_has_decrkeydata();
}
inline const ::std::string& privateKey::decrkeydata() const {
  return *decrkeydata_;
}
inline void privateKey::set_decrkeydata(const ::std::string& value) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(value);
}
inline void privateKey::set_decrkeydata(const char* value) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(value);
}
inline void privateKey::set_decrkeydata(const void* value, size_t size) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_decrkeydata() {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  return decrkeydata_;
}
inline ::std::string* privateKey::release_decrkeydata() {
  clear_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = decrkeydata_;
    decrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_decrkeydata(::std::string* decrkeydata) {
  if (decrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete decrkeydata_;
  }
  if (decrkeydata) {
    set_has_decrkeydata();
    decrkeydata_ = decrkeydata;
  } else {
    clear_has_decrkeydata();
    decrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signKeyData = 10;
inline bool privateKey::has_signkeydata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void privateKey::set_has_signkeydata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void privateKey::clear_has_signkeydata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void privateKey::clear_signkeydata() {
  if (signkeydata_ != &::google::protobuf::internal::kEmptyString) {
    signkeydata_->clear();
  }
  clear_has_signkeydata();
}
inline const ::std::string& privateKey::signkeydata() const {
  return *signkeydata_;
}
inline void privateKey::set_signkeydata(const ::std::string& value) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(value);
}
inline void privateKey::set_signkeydata(const char* value) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(value);
}
inline void privateKey::set_signkeydata(const void* value, size_t size) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_signkeydata() {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  return signkeydata_;
}
inline ::std::string* privateKey::release_signkeydata() {
  clear_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signkeydata_;
    signkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_signkeydata(::std::string* signkeydata) {
  if (signkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete signkeydata_;
  }
  if (signkeydata) {
    set_has_signkeydata();
    signkeydata_ = signkeydata;
  } else {
    clear_has_signkeydata();
    signkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 11;
inline bool privateKey::has_email() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void privateKey::set_has_email() {
  _has_bits_[0] |= 0x00000400u;
}
inline void privateKey::clear_has_email() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void privateKey::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& privateKey::email() const {
  return *email_;
}
inline void privateKey::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void privateKey::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void privateKey::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* privateKey::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isCurrent = 12;
inline bool privateKey::has_iscurrent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void privateKey::set_has_iscurrent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void privateKey::clear_has_iscurrent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void privateKey::clear_iscurrent() {
  iscurrent_ = false;
  clear_has_iscurrent();
}
inline bool privateKey::iscurrent() const {
  return iscurrent_;
}
inline void privateKey::set_iscurrent(bool value) {
  set_has_iscurrent();
  iscurrent_ = value;
}

// repeated string emailAddresses = 13;
inline int privateKey::emailaddresses_size() const {
  return emailaddresses_.size();
}
inline void privateKey::clear_emailaddresses() {
  emailaddresses_.Clear();
}
inline const ::std::string& privateKey::emailaddresses(int index) const {
  return emailaddresses_.Get(index);
}
inline ::std::string* privateKey::mutable_emailaddresses(int index) {
  return emailaddresses_.Mutable(index);
}
inline void privateKey::set_emailaddresses(int index, const ::std::string& value) {
  emailaddresses_.Mutable(index)->assign(value);
}
inline void privateKey::set_emailaddresses(int index, const char* value) {
  emailaddresses_.Mutable(index)->assign(value);
}
inline void privateKey::set_emailaddresses(int index, const char* value, size_t size) {
  emailaddresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_emailaddresses() {
  return emailaddresses_.Add();
}
inline void privateKey::add_emailaddresses(const ::std::string& value) {
  emailaddresses_.Add()->assign(value);
}
inline void privateKey::add_emailaddresses(const char* value) {
  emailaddresses_.Add()->assign(value);
}
inline void privateKey::add_emailaddresses(const char* value, size_t size) {
  emailaddresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::emailaddresses() const {
  return emailaddresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_emailaddresses() {
  return &emailaddresses_;
}

// -------------------------------------------------------------------

// publicKey

// required bytes encrKeyData = 1;
inline bool publicKey::has_encrkeydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void publicKey::set_has_encrkeydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void publicKey::clear_has_encrkeydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void publicKey::clear_encrkeydata() {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    encrkeydata_->clear();
  }
  clear_has_encrkeydata();
}
inline const ::std::string& publicKey::encrkeydata() const {
  return *encrkeydata_;
}
inline void publicKey::set_encrkeydata(const ::std::string& value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void publicKey::set_encrkeydata(const char* value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void publicKey::set_encrkeydata(const void* value, size_t size) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_encrkeydata() {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  return encrkeydata_;
}
inline ::std::string* publicKey::release_encrkeydata() {
  clear_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrkeydata_;
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_encrkeydata(::std::string* encrkeydata) {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrkeydata_;
  }
  if (encrkeydata) {
    set_has_encrkeydata();
    encrkeydata_ = encrkeydata;
  } else {
    clear_has_encrkeydata();
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes verKeyData = 2;
inline bool publicKey::has_verkeydata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void publicKey::set_has_verkeydata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void publicKey::clear_has_verkeydata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void publicKey::clear_verkeydata() {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    verkeydata_->clear();
  }
  clear_has_verkeydata();
}
inline const ::std::string& publicKey::verkeydata() const {
  return *verkeydata_;
}
inline void publicKey::set_verkeydata(const ::std::string& value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void publicKey::set_verkeydata(const char* value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void publicKey::set_verkeydata(const void* value, size_t size) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_verkeydata() {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  return verkeydata_;
}
inline ::std::string* publicKey::release_verkeydata() {
  clear_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verkeydata_;
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_verkeydata(::std::string* verkeydata) {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete verkeydata_;
  }
  if (verkeydata) {
    set_has_verkeydata();
    verkeydata_ = verkeydata;
  } else {
    clear_has_verkeydata();
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string keyLabel = 3;
inline bool publicKey::has_keylabel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void publicKey::set_has_keylabel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void publicKey::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void publicKey::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& publicKey::keylabel() const {
  return *keylabel_;
}
inline void publicKey::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void publicKey::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void publicKey::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* publicKey::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateCreated = 4;
inline bool publicKey::has_datecreated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void publicKey::set_has_datecreated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void publicKey::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void publicKey::clear_datecreated() {
  datecreated_ = 0;
  clear_has_datecreated();
}
inline ::google::protobuf::int32 publicKey::datecreated() const {
  return datecreated_;
}
inline void publicKey::set_datecreated(::google::protobuf::int32 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// optional bool compromised = 5;
inline bool publicKey::has_compromised() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void publicKey::set_has_compromised() {
  _has_bits_[0] |= 0x00000010u;
}
inline void publicKey::clear_has_compromised() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void publicKey::clear_compromised() {
  compromised_ = false;
  clear_has_compromised();
}
inline bool publicKey::compromised() const {
  return compromised_;
}
inline void publicKey::set_compromised(bool value) {
  set_has_compromised();
  compromised_ = value;
}

// optional string version = 6;
inline bool publicKey::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void publicKey::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void publicKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void publicKey::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& publicKey::version() const {
  return *version_;
}
inline void publicKey::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void publicKey::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void publicKey::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* publicKey::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string currentKeyForEmail = 7;
inline int publicKey::currentkeyforemail_size() const {
  return currentkeyforemail_.size();
}
inline void publicKey::clear_currentkeyforemail() {
  currentkeyforemail_.Clear();
}
inline const ::std::string& publicKey::currentkeyforemail(int index) const {
  return currentkeyforemail_.Get(index);
}
inline ::std::string* publicKey::mutable_currentkeyforemail(int index) {
  return currentkeyforemail_.Mutable(index);
}
inline void publicKey::set_currentkeyforemail(int index, const ::std::string& value) {
  currentkeyforemail_.Mutable(index)->assign(value);
}
inline void publicKey::set_currentkeyforemail(int index, const char* value) {
  currentkeyforemail_.Mutable(index)->assign(value);
}
inline void publicKey::set_currentkeyforemail(int index, const char* value, size_t size) {
  currentkeyforemail_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_currentkeyforemail() {
  return currentkeyforemail_.Add();
}
inline void publicKey::add_currentkeyforemail(const ::std::string& value) {
  currentkeyforemail_.Add()->assign(value);
}
inline void publicKey::add_currentkeyforemail(const char* value) {
  currentkeyforemail_.Add()->assign(value);
}
inline void publicKey::add_currentkeyforemail(const char* value, size_t size) {
  currentkeyforemail_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::currentkeyforemail() const {
  return currentkeyforemail_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_currentkeyforemail() {
  return &currentkeyforemail_;
}

// optional int32 dateObtained = 8;
inline bool publicKey::has_dateobtained() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void publicKey::set_has_dateobtained() {
  _has_bits_[0] |= 0x00000080u;
}
inline void publicKey::clear_has_dateobtained() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void publicKey::clear_dateobtained() {
  dateobtained_ = 0;
  clear_has_dateobtained();
}
inline ::google::protobuf::int32 publicKey::dateobtained() const {
  return dateobtained_;
}
inline void publicKey::set_dateobtained(::google::protobuf::int32 value) {
  set_has_dateobtained();
  dateobtained_ = value;
}

// optional int32 dateDeclared = 9;
inline bool publicKey::has_datedeclared() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void publicKey::set_has_datedeclared() {
  _has_bits_[0] |= 0x00000100u;
}
inline void publicKey::clear_has_datedeclared() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void publicKey::clear_datedeclared() {
  datedeclared_ = 0;
  clear_has_datedeclared();
}
inline ::google::protobuf::int32 publicKey::datedeclared() const {
  return datedeclared_;
}
inline void publicKey::set_datedeclared(::google::protobuf::int32 value) {
  set_has_datedeclared();
  datedeclared_ = value;
}

// optional bool isCompromised = 10;
inline bool publicKey::has_iscompromised() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void publicKey::set_has_iscompromised() {
  _has_bits_[0] |= 0x00000200u;
}
inline void publicKey::clear_has_iscompromised() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void publicKey::clear_iscompromised() {
  iscompromised_ = false;
  clear_has_iscompromised();
}
inline bool publicKey::iscompromised() const {
  return iscompromised_;
}
inline void publicKey::set_iscompromised(bool value) {
  set_has_iscompromised();
  iscompromised_ = value;
}

// optional bool fromServer = 11;
inline bool publicKey::has_fromserver() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void publicKey::set_has_fromserver() {
  _has_bits_[0] |= 0x00000400u;
}
inline void publicKey::clear_has_fromserver() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void publicKey::clear_fromserver() {
  fromserver_ = false;
  clear_has_fromserver();
}
inline bool publicKey::fromserver() const {
  return fromserver_;
}
inline void publicKey::set_fromserver(bool value) {
  set_has_fromserver();
  fromserver_ = value;
}

// repeated string introducesKeys = 12;
inline int publicKey::introduceskeys_size() const {
  return introduceskeys_.size();
}
inline void publicKey::clear_introduceskeys() {
  introduceskeys_.Clear();
}
inline const ::std::string& publicKey::introduceskeys(int index) const {
  return introduceskeys_.Get(index);
}
inline ::std::string* publicKey::mutable_introduceskeys(int index) {
  return introduceskeys_.Mutable(index);
}
inline void publicKey::set_introduceskeys(int index, const ::std::string& value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_introduceskeys(int index, const char* value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_introduceskeys(int index, const char* value, size_t size) {
  introduceskeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_introduceskeys() {
  return introduceskeys_.Add();
}
inline void publicKey::add_introduceskeys(const ::std::string& value) {
  introduceskeys_.Add()->assign(value);
}
inline void publicKey::add_introduceskeys(const char* value) {
  introduceskeys_.Add()->assign(value);
}
inline void publicKey::add_introduceskeys(const char* value, size_t size) {
  introduceskeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::introduceskeys() const {
  return introduceskeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_introduceskeys() {
  return &introduceskeys_;
}

// repeated string isIntroducedByKeys = 13;
inline int publicKey::isintroducedbykeys_size() const {
  return isintroducedbykeys_.size();
}
inline void publicKey::clear_isintroducedbykeys() {
  isintroducedbykeys_.Clear();
}
inline const ::std::string& publicKey::isintroducedbykeys(int index) const {
  return isintroducedbykeys_.Get(index);
}
inline ::std::string* publicKey::mutable_isintroducedbykeys(int index) {
  return isintroducedbykeys_.Mutable(index);
}
inline void publicKey::set_isintroducedbykeys(int index, const ::std::string& value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_isintroducedbykeys(int index, const char* value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_isintroducedbykeys(int index, const char* value, size_t size) {
  isintroducedbykeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_isintroducedbykeys() {
  return isintroducedbykeys_.Add();
}
inline void publicKey::add_isintroducedbykeys(const ::std::string& value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void publicKey::add_isintroducedbykeys(const char* value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void publicKey::add_isintroducedbykeys(const char* value, size_t size) {
  isintroducedbykeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::isintroducedbykeys() const {
  return isintroducedbykeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_isintroducedbykeys() {
  return &isintroducedbykeys_;
}

// optional string email = 14;
inline bool publicKey::has_email() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void publicKey::set_has_email() {
  _has_bits_[0] |= 0x00002000u;
}
inline void publicKey::clear_has_email() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void publicKey::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& publicKey::email() const {
  return *email_;
}
inline void publicKey::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void publicKey::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void publicKey::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* publicKey::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isCurrent = 15;
inline bool publicKey::has_iscurrent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void publicKey::set_has_iscurrent() {
  _has_bits_[0] |= 0x00004000u;
}
inline void publicKey::clear_has_iscurrent() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void publicKey::clear_iscurrent() {
  iscurrent_ = false;
  clear_has_iscurrent();
}
inline bool publicKey::iscurrent() const {
  return iscurrent_;
}
inline void publicKey::set_iscurrent(bool value) {
  set_has_iscurrent();
  iscurrent_ = value;
}

// -------------------------------------------------------------------

// accountLoginData

// required string inHostname = 1;
inline bool accountLoginData::has_inhostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void accountLoginData::set_has_inhostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void accountLoginData::clear_has_inhostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void accountLoginData::clear_inhostname() {
  if (inhostname_ != &::google::protobuf::internal::kEmptyString) {
    inhostname_->clear();
  }
  clear_has_inhostname();
}
inline const ::std::string& accountLoginData::inhostname() const {
  return *inhostname_;
}
inline void accountLoginData::set_inhostname(const ::std::string& value) {
  set_has_inhostname();
  if (inhostname_ == &::google::protobuf::internal::kEmptyString) {
    inhostname_ = new ::std::string;
  }
  inhostname_->assign(value);
}
inline void accountLoginData::set_inhostname(const char* value) {
  set_has_inhostname();
  if (inhostname_ == &::google::protobuf::internal::kEmptyString) {
    inhostname_ = new ::std::string;
  }
  inhostname_->assign(value);
}
inline void accountLoginData::set_inhostname(const char* value, size_t size) {
  set_has_inhostname();
  if (inhostname_ == &::google::protobuf::internal::kEmptyString) {
    inhostname_ = new ::std::string;
  }
  inhostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_inhostname() {
  set_has_inhostname();
  if (inhostname_ == &::google::protobuf::internal::kEmptyString) {
    inhostname_ = new ::std::string;
  }
  return inhostname_;
}
inline ::std::string* accountLoginData::release_inhostname() {
  clear_has_inhostname();
  if (inhostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inhostname_;
    inhostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_inhostname(::std::string* inhostname) {
  if (inhostname_ != &::google::protobuf::internal::kEmptyString) {
    delete inhostname_;
  }
  if (inhostname) {
    set_has_inhostname();
    inhostname_ = inhostname;
  } else {
    clear_has_inhostname();
    inhostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string outHostname = 2;
inline bool accountLoginData::has_outhostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void accountLoginData::set_has_outhostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void accountLoginData::clear_has_outhostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void accountLoginData::clear_outhostname() {
  if (outhostname_ != &::google::protobuf::internal::kEmptyString) {
    outhostname_->clear();
  }
  clear_has_outhostname();
}
inline const ::std::string& accountLoginData::outhostname() const {
  return *outhostname_;
}
inline void accountLoginData::set_outhostname(const ::std::string& value) {
  set_has_outhostname();
  if (outhostname_ == &::google::protobuf::internal::kEmptyString) {
    outhostname_ = new ::std::string;
  }
  outhostname_->assign(value);
}
inline void accountLoginData::set_outhostname(const char* value) {
  set_has_outhostname();
  if (outhostname_ == &::google::protobuf::internal::kEmptyString) {
    outhostname_ = new ::std::string;
  }
  outhostname_->assign(value);
}
inline void accountLoginData::set_outhostname(const char* value, size_t size) {
  set_has_outhostname();
  if (outhostname_ == &::google::protobuf::internal::kEmptyString) {
    outhostname_ = new ::std::string;
  }
  outhostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_outhostname() {
  set_has_outhostname();
  if (outhostname_ == &::google::protobuf::internal::kEmptyString) {
    outhostname_ = new ::std::string;
  }
  return outhostname_;
}
inline ::std::string* accountLoginData::release_outhostname() {
  clear_has_outhostname();
  if (outhostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outhostname_;
    outhostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_outhostname(::std::string* outhostname) {
  if (outhostname_ != &::google::protobuf::internal::kEmptyString) {
    delete outhostname_;
  }
  if (outhostname) {
    set_has_outhostname();
    outhostname_ = outhostname;
  } else {
    clear_has_outhostname();
    outhostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string inUserName = 3;
inline bool accountLoginData::has_inusername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void accountLoginData::set_has_inusername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void accountLoginData::clear_has_inusername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void accountLoginData::clear_inusername() {
  if (inusername_ != &::google::protobuf::internal::kEmptyString) {
    inusername_->clear();
  }
  clear_has_inusername();
}
inline const ::std::string& accountLoginData::inusername() const {
  return *inusername_;
}
inline void accountLoginData::set_inusername(const ::std::string& value) {
  set_has_inusername();
  if (inusername_ == &::google::protobuf::internal::kEmptyString) {
    inusername_ = new ::std::string;
  }
  inusername_->assign(value);
}
inline void accountLoginData::set_inusername(const char* value) {
  set_has_inusername();
  if (inusername_ == &::google::protobuf::internal::kEmptyString) {
    inusername_ = new ::std::string;
  }
  inusername_->assign(value);
}
inline void accountLoginData::set_inusername(const char* value, size_t size) {
  set_has_inusername();
  if (inusername_ == &::google::protobuf::internal::kEmptyString) {
    inusername_ = new ::std::string;
  }
  inusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_inusername() {
  set_has_inusername();
  if (inusername_ == &::google::protobuf::internal::kEmptyString) {
    inusername_ = new ::std::string;
  }
  return inusername_;
}
inline ::std::string* accountLoginData::release_inusername() {
  clear_has_inusername();
  if (inusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inusername_;
    inusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_inusername(::std::string* inusername) {
  if (inusername_ != &::google::protobuf::internal::kEmptyString) {
    delete inusername_;
  }
  if (inusername) {
    set_has_inusername();
    inusername_ = inusername;
  } else {
    clear_has_inusername();
    inusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string outUserName = 4;
inline bool accountLoginData::has_outusername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void accountLoginData::set_has_outusername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void accountLoginData::clear_has_outusername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void accountLoginData::clear_outusername() {
  if (outusername_ != &::google::protobuf::internal::kEmptyString) {
    outusername_->clear();
  }
  clear_has_outusername();
}
inline const ::std::string& accountLoginData::outusername() const {
  return *outusername_;
}
inline void accountLoginData::set_outusername(const ::std::string& value) {
  set_has_outusername();
  if (outusername_ == &::google::protobuf::internal::kEmptyString) {
    outusername_ = new ::std::string;
  }
  outusername_->assign(value);
}
inline void accountLoginData::set_outusername(const char* value) {
  set_has_outusername();
  if (outusername_ == &::google::protobuf::internal::kEmptyString) {
    outusername_ = new ::std::string;
  }
  outusername_->assign(value);
}
inline void accountLoginData::set_outusername(const char* value, size_t size) {
  set_has_outusername();
  if (outusername_ == &::google::protobuf::internal::kEmptyString) {
    outusername_ = new ::std::string;
  }
  outusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_outusername() {
  set_has_outusername();
  if (outusername_ == &::google::protobuf::internal::kEmptyString) {
    outusername_ = new ::std::string;
  }
  return outusername_;
}
inline ::std::string* accountLoginData::release_outusername() {
  clear_has_outusername();
  if (outusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outusername_;
    outusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_outusername(::std::string* outusername) {
  if (outusername_ != &::google::protobuf::internal::kEmptyString) {
    delete outusername_;
  }
  if (outusername) {
    set_has_outusername();
    outusername_ = outusername;
  } else {
    clear_has_outusername();
    outusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string inPassword = 5;
inline bool accountLoginData::has_inpassword() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void accountLoginData::set_has_inpassword() {
  _has_bits_[0] |= 0x00000010u;
}
inline void accountLoginData::clear_has_inpassword() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void accountLoginData::clear_inpassword() {
  if (inpassword_ != &::google::protobuf::internal::kEmptyString) {
    inpassword_->clear();
  }
  clear_has_inpassword();
}
inline const ::std::string& accountLoginData::inpassword() const {
  return *inpassword_;
}
inline void accountLoginData::set_inpassword(const ::std::string& value) {
  set_has_inpassword();
  if (inpassword_ == &::google::protobuf::internal::kEmptyString) {
    inpassword_ = new ::std::string;
  }
  inpassword_->assign(value);
}
inline void accountLoginData::set_inpassword(const char* value) {
  set_has_inpassword();
  if (inpassword_ == &::google::protobuf::internal::kEmptyString) {
    inpassword_ = new ::std::string;
  }
  inpassword_->assign(value);
}
inline void accountLoginData::set_inpassword(const char* value, size_t size) {
  set_has_inpassword();
  if (inpassword_ == &::google::protobuf::internal::kEmptyString) {
    inpassword_ = new ::std::string;
  }
  inpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_inpassword() {
  set_has_inpassword();
  if (inpassword_ == &::google::protobuf::internal::kEmptyString) {
    inpassword_ = new ::std::string;
  }
  return inpassword_;
}
inline ::std::string* accountLoginData::release_inpassword() {
  clear_has_inpassword();
  if (inpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inpassword_;
    inpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_inpassword(::std::string* inpassword) {
  if (inpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete inpassword_;
  }
  if (inpassword) {
    set_has_inpassword();
    inpassword_ = inpassword;
  } else {
    clear_has_inpassword();
    inpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string outPassword = 6;
inline bool accountLoginData::has_outpassword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void accountLoginData::set_has_outpassword() {
  _has_bits_[0] |= 0x00000020u;
}
inline void accountLoginData::clear_has_outpassword() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void accountLoginData::clear_outpassword() {
  if (outpassword_ != &::google::protobuf::internal::kEmptyString) {
    outpassword_->clear();
  }
  clear_has_outpassword();
}
inline const ::std::string& accountLoginData::outpassword() const {
  return *outpassword_;
}
inline void accountLoginData::set_outpassword(const ::std::string& value) {
  set_has_outpassword();
  if (outpassword_ == &::google::protobuf::internal::kEmptyString) {
    outpassword_ = new ::std::string;
  }
  outpassword_->assign(value);
}
inline void accountLoginData::set_outpassword(const char* value) {
  set_has_outpassword();
  if (outpassword_ == &::google::protobuf::internal::kEmptyString) {
    outpassword_ = new ::std::string;
  }
  outpassword_->assign(value);
}
inline void accountLoginData::set_outpassword(const char* value, size_t size) {
  set_has_outpassword();
  if (outpassword_ == &::google::protobuf::internal::kEmptyString) {
    outpassword_ = new ::std::string;
  }
  outpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_outpassword() {
  set_has_outpassword();
  if (outpassword_ == &::google::protobuf::internal::kEmptyString) {
    outpassword_ = new ::std::string;
  }
  return outpassword_;
}
inline ::std::string* accountLoginData::release_outpassword() {
  clear_has_outpassword();
  if (outpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outpassword_;
    outpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_outpassword(::std::string* outpassword) {
  if (outpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete outpassword_;
  }
  if (outpassword) {
    set_has_outpassword();
    outpassword_ = outpassword;
  } else {
    clear_has_outpassword();
    outpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 inPort = 7;
inline bool accountLoginData::has_inport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void accountLoginData::set_has_inport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void accountLoginData::clear_has_inport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void accountLoginData::clear_inport() {
  inport_ = 0;
  clear_has_inport();
}
inline ::google::protobuf::int32 accountLoginData::inport() const {
  return inport_;
}
inline void accountLoginData::set_inport(::google::protobuf::int32 value) {
  set_has_inport();
  inport_ = value;
}

// required int32 outPort = 8;
inline bool accountLoginData::has_outport() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void accountLoginData::set_has_outport() {
  _has_bits_[0] |= 0x00000080u;
}
inline void accountLoginData::clear_has_outport() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void accountLoginData::clear_outport() {
  outport_ = 0;
  clear_has_outport();
}
inline ::google::protobuf::int32 accountLoginData::outport() const {
  return outport_;
}
inline void accountLoginData::set_outport(::google::protobuf::int32 value) {
  set_has_outport();
  outport_ = value;
}

// required int32 inEncryption = 9;
inline bool accountLoginData::has_inencryption() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void accountLoginData::set_has_inencryption() {
  _has_bits_[0] |= 0x00000100u;
}
inline void accountLoginData::clear_has_inencryption() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void accountLoginData::clear_inencryption() {
  inencryption_ = 0;
  clear_has_inencryption();
}
inline ::google::protobuf::int32 accountLoginData::inencryption() const {
  return inencryption_;
}
inline void accountLoginData::set_inencryption(::google::protobuf::int32 value) {
  set_has_inencryption();
  inencryption_ = value;
}

// required int32 outEncryption = 10;
inline bool accountLoginData::has_outencryption() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void accountLoginData::set_has_outencryption() {
  _has_bits_[0] |= 0x00000200u;
}
inline void accountLoginData::clear_has_outencryption() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void accountLoginData::clear_outencryption() {
  outencryption_ = 0;
  clear_has_outencryption();
}
inline ::google::protobuf::int32 accountLoginData::outencryption() const {
  return outencryption_;
}
inline void accountLoginData::set_outencryption(::google::protobuf::int32 value) {
  set_has_outencryption();
  outencryption_ = value;
}

// required int32 inAuthType = 11;
inline bool accountLoginData::has_inauthtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void accountLoginData::set_has_inauthtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void accountLoginData::clear_has_inauthtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void accountLoginData::clear_inauthtype() {
  inauthtype_ = 0;
  clear_has_inauthtype();
}
inline ::google::protobuf::int32 accountLoginData::inauthtype() const {
  return inauthtype_;
}
inline void accountLoginData::set_inauthtype(::google::protobuf::int32 value) {
  set_has_inauthtype();
  inauthtype_ = value;
}

// required int32 outAuthType = 12;
inline bool accountLoginData::has_outauthtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void accountLoginData::set_has_outauthtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void accountLoginData::clear_has_outauthtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void accountLoginData::clear_outauthtype() {
  outauthtype_ = 0;
  clear_has_outauthtype();
}
inline ::google::protobuf::int32 accountLoginData::outauthtype() const {
  return outauthtype_;
}
inline void accountLoginData::set_outauthtype(::google::protobuf::int32 value) {
  set_has_outauthtype();
  outauthtype_ = value;
}

// required string email = 13;
inline bool accountLoginData::has_email() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void accountLoginData::set_has_email() {
  _has_bits_[0] |= 0x00001000u;
}
inline void accountLoginData::clear_has_email() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void accountLoginData::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& accountLoginData::email() const {
  return *email_;
}
inline void accountLoginData::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void accountLoginData::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void accountLoginData::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* accountLoginData::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string senderName = 14;
inline bool accountLoginData::has_sendername() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void accountLoginData::set_has_sendername() {
  _has_bits_[0] |= 0x00002000u;
}
inline void accountLoginData::clear_has_sendername() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void accountLoginData::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& accountLoginData::sendername() const {
  return *sendername_;
}
inline void accountLoginData::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void accountLoginData::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void accountLoginData::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* accountLoginData::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string senderEmail = 15;
inline bool accountLoginData::has_senderemail() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void accountLoginData::set_has_senderemail() {
  _has_bits_[0] |= 0x00004000u;
}
inline void accountLoginData::clear_has_senderemail() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void accountLoginData::clear_senderemail() {
  if (senderemail_ != &::google::protobuf::internal::kEmptyString) {
    senderemail_->clear();
  }
  clear_has_senderemail();
}
inline const ::std::string& accountLoginData::senderemail() const {
  return *senderemail_;
}
inline void accountLoginData::set_senderemail(const ::std::string& value) {
  set_has_senderemail();
  if (senderemail_ == &::google::protobuf::internal::kEmptyString) {
    senderemail_ = new ::std::string;
  }
  senderemail_->assign(value);
}
inline void accountLoginData::set_senderemail(const char* value) {
  set_has_senderemail();
  if (senderemail_ == &::google::protobuf::internal::kEmptyString) {
    senderemail_ = new ::std::string;
  }
  senderemail_->assign(value);
}
inline void accountLoginData::set_senderemail(const char* value, size_t size) {
  set_has_senderemail();
  if (senderemail_ == &::google::protobuf::internal::kEmptyString) {
    senderemail_ = new ::std::string;
  }
  senderemail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_senderemail() {
  set_has_senderemail();
  if (senderemail_ == &::google::protobuf::internal::kEmptyString) {
    senderemail_ = new ::std::string;
  }
  return senderemail_;
}
inline ::std::string* accountLoginData::release_senderemail() {
  clear_has_senderemail();
  if (senderemail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = senderemail_;
    senderemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_senderemail(::std::string* senderemail) {
  if (senderemail_ != &::google::protobuf::internal::kEmptyString) {
    delete senderemail_;
  }
  if (senderemail) {
    set_has_senderemail();
    senderemail_ = senderemail;
  } else {
    clear_has_senderemail();
    senderemail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string displayName = 16;
inline bool accountLoginData::has_displayname() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void accountLoginData::set_has_displayname() {
  _has_bits_[0] |= 0x00008000u;
}
inline void accountLoginData::clear_has_displayname() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void accountLoginData::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& accountLoginData::displayname() const {
  return *displayname_;
}
inline void accountLoginData::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void accountLoginData::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void accountLoginData::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accountLoginData::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* accountLoginData::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accountLoginData::set_allocated_displayname(::std::string* displayname) {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    delete displayname_;
  }
  if (displayname) {
    set_has_displayname();
    displayname_ = displayname;
  } else {
    clear_has_displayname();
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool copyIntoSent = 17;
inline bool accountLoginData::has_copyintosent() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void accountLoginData::set_has_copyintosent() {
  _has_bits_[0] |= 0x00010000u;
}
inline void accountLoginData::clear_has_copyintosent() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void accountLoginData::clear_copyintosent() {
  copyintosent_ = false;
  clear_has_copyintosent();
}
inline bool accountLoginData::copyintosent() const {
  return copyintosent_;
}
inline void accountLoginData::set_copyintosent(bool value) {
  set_has_copyintosent();
  copyintosent_ = value;
}

// -------------------------------------------------------------------

// confidentialAccountData

// repeated .mynigma.privateKey privKeys = 1;
inline int confidentialAccountData::privkeys_size() const {
  return privkeys_.size();
}
inline void confidentialAccountData::clear_privkeys() {
  privkeys_.Clear();
}
inline const ::mynigma::privateKey& confidentialAccountData::privkeys(int index) const {
  return privkeys_.Get(index);
}
inline ::mynigma::privateKey* confidentialAccountData::mutable_privkeys(int index) {
  return privkeys_.Mutable(index);
}
inline ::mynigma::privateKey* confidentialAccountData::add_privkeys() {
  return privkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >&
confidentialAccountData::privkeys() const {
  return privkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >*
confidentialAccountData::mutable_privkeys() {
  return &privkeys_;
}

// repeated .mynigma.publicKey pubKeys = 2;
inline int confidentialAccountData::pubkeys_size() const {
  return pubkeys_.size();
}
inline void confidentialAccountData::clear_pubkeys() {
  pubkeys_.Clear();
}
inline const ::mynigma::publicKey& confidentialAccountData::pubkeys(int index) const {
  return pubkeys_.Get(index);
}
inline ::mynigma::publicKey* confidentialAccountData::mutable_pubkeys(int index) {
  return pubkeys_.Mutable(index);
}
inline ::mynigma::publicKey* confidentialAccountData::add_pubkeys() {
  return pubkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >&
confidentialAccountData::pubkeys() const {
  return pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >*
confidentialAccountData::mutable_pubkeys() {
  return &pubkeys_;
}

// repeated .mynigma.accountLoginData accounts = 3;
inline int confidentialAccountData::accounts_size() const {
  return accounts_.size();
}
inline void confidentialAccountData::clear_accounts() {
  accounts_.Clear();
}
inline const ::mynigma::accountLoginData& confidentialAccountData::accounts(int index) const {
  return accounts_.Get(index);
}
inline ::mynigma::accountLoginData* confidentialAccountData::mutable_accounts(int index) {
  return accounts_.Mutable(index);
}
inline ::mynigma::accountLoginData* confidentialAccountData::add_accounts() {
  return accounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >&
confidentialAccountData::accounts() const {
  return accounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >*
confidentialAccountData::mutable_accounts() {
  return &accounts_;
}

// optional string version = 4;
inline bool confidentialAccountData::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void confidentialAccountData::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void confidentialAccountData::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void confidentialAccountData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& confidentialAccountData::version() const {
  return *version_;
}
inline void confidentialAccountData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void confidentialAccountData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void confidentialAccountData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* confidentialAccountData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* confidentialAccountData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void confidentialAccountData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// contactDetail

// optional string firstName = 1;
inline bool contactDetail::has_firstname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void contactDetail::set_has_firstname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void contactDetail::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void contactDetail::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::kEmptyString) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& contactDetail::firstname() const {
  return *firstname_;
}
inline void contactDetail::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
}
inline void contactDetail::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
}
inline void contactDetail::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* contactDetail::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  return firstname_;
}
inline ::std::string* contactDetail::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void contactDetail::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::kEmptyString) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lastName = 2;
inline bool contactDetail::has_lastname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void contactDetail::set_has_lastname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void contactDetail::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void contactDetail::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::kEmptyString) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& contactDetail::lastname() const {
  return *lastname_;
}
inline void contactDetail::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
}
inline void contactDetail::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
}
inline void contactDetail::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* contactDetail::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  return lastname_;
}
inline ::std::string* contactDetail::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void contactDetail::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::kEmptyString) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string emailAddress = 3;
inline bool contactDetail::has_emailaddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void contactDetail::set_has_emailaddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void contactDetail::clear_has_emailaddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void contactDetail::clear_emailaddress() {
  if (emailaddress_ != &::google::protobuf::internal::kEmptyString) {
    emailaddress_->clear();
  }
  clear_has_emailaddress();
}
inline const ::std::string& contactDetail::emailaddress() const {
  return *emailaddress_;
}
inline void contactDetail::set_emailaddress(const ::std::string& value) {
  set_has_emailaddress();
  if (emailaddress_ == &::google::protobuf::internal::kEmptyString) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(value);
}
inline void contactDetail::set_emailaddress(const char* value) {
  set_has_emailaddress();
  if (emailaddress_ == &::google::protobuf::internal::kEmptyString) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(value);
}
inline void contactDetail::set_emailaddress(const char* value, size_t size) {
  set_has_emailaddress();
  if (emailaddress_ == &::google::protobuf::internal::kEmptyString) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* contactDetail::mutable_emailaddress() {
  set_has_emailaddress();
  if (emailaddress_ == &::google::protobuf::internal::kEmptyString) {
    emailaddress_ = new ::std::string;
  }
  return emailaddress_;
}
inline ::std::string* contactDetail::release_emailaddress() {
  clear_has_emailaddress();
  if (emailaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emailaddress_;
    emailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void contactDetail::set_allocated_emailaddress(::std::string* emailaddress) {
  if (emailaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete emailaddress_;
  }
  if (emailaddress) {
    set_has_emailaddress();
    emailaddress_ = emailaddress;
  } else {
    clear_has_emailaddress();
    emailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currentSentKey = 4;
inline bool contactDetail::has_currentsentkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void contactDetail::set_has_currentsentkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void contactDetail::clear_has_currentsentkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void contactDetail::clear_currentsentkey() {
  if (currentsentkey_ != &::google::protobuf::internal::kEmptyString) {
    currentsentkey_->clear();
  }
  clear_has_currentsentkey();
}
inline const ::std::string& contactDetail::currentsentkey() const {
  return *currentsentkey_;
}
inline void contactDetail::set_currentsentkey(const ::std::string& value) {
  set_has_currentsentkey();
  if (currentsentkey_ == &::google::protobuf::internal::kEmptyString) {
    currentsentkey_ = new ::std::string;
  }
  currentsentkey_->assign(value);
}
inline void contactDetail::set_currentsentkey(const char* value) {
  set_has_currentsentkey();
  if (currentsentkey_ == &::google::protobuf::internal::kEmptyString) {
    currentsentkey_ = new ::std::string;
  }
  currentsentkey_->assign(value);
}
inline void contactDetail::set_currentsentkey(const char* value, size_t size) {
  set_has_currentsentkey();
  if (currentsentkey_ == &::google::protobuf::internal::kEmptyString) {
    currentsentkey_ = new ::std::string;
  }
  currentsentkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* contactDetail::mutable_currentsentkey() {
  set_has_currentsentkey();
  if (currentsentkey_ == &::google::protobuf::internal::kEmptyString) {
    currentsentkey_ = new ::std::string;
  }
  return currentsentkey_;
}
inline ::std::string* contactDetail::release_currentsentkey() {
  clear_has_currentsentkey();
  if (currentsentkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentsentkey_;
    currentsentkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void contactDetail::set_allocated_currentsentkey(::std::string* currentsentkey) {
  if (currentsentkey_ != &::google::protobuf::internal::kEmptyString) {
    delete currentsentkey_;
  }
  if (currentsentkey) {
    set_has_currentsentkey();
    currentsentkey_ = currentsentkey;
  } else {
    clear_has_currentsentkey();
    currentsentkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateSentKey = 5;
inline bool contactDetail::has_datesentkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void contactDetail::set_has_datesentkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void contactDetail::clear_has_datesentkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void contactDetail::clear_datesentkey() {
  datesentkey_ = 0;
  clear_has_datesentkey();
}
inline ::google::protobuf::int32 contactDetail::datesentkey() const {
  return datesentkey_;
}
inline void contactDetail::set_datesentkey(::google::protobuf::int32 value) {
  set_has_datesentkey();
  datesentkey_ = value;
}

// optional string currentReceivedKey = 6;
inline bool contactDetail::has_currentreceivedkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void contactDetail::set_has_currentreceivedkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void contactDetail::clear_has_currentreceivedkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void contactDetail::clear_currentreceivedkey() {
  if (currentreceivedkey_ != &::google::protobuf::internal::kEmptyString) {
    currentreceivedkey_->clear();
  }
  clear_has_currentreceivedkey();
}
inline const ::std::string& contactDetail::currentreceivedkey() const {
  return *currentreceivedkey_;
}
inline void contactDetail::set_currentreceivedkey(const ::std::string& value) {
  set_has_currentreceivedkey();
  if (currentreceivedkey_ == &::google::protobuf::internal::kEmptyString) {
    currentreceivedkey_ = new ::std::string;
  }
  currentreceivedkey_->assign(value);
}
inline void contactDetail::set_currentreceivedkey(const char* value) {
  set_has_currentreceivedkey();
  if (currentreceivedkey_ == &::google::protobuf::internal::kEmptyString) {
    currentreceivedkey_ = new ::std::string;
  }
  currentreceivedkey_->assign(value);
}
inline void contactDetail::set_currentreceivedkey(const char* value, size_t size) {
  set_has_currentreceivedkey();
  if (currentreceivedkey_ == &::google::protobuf::internal::kEmptyString) {
    currentreceivedkey_ = new ::std::string;
  }
  currentreceivedkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* contactDetail::mutable_currentreceivedkey() {
  set_has_currentreceivedkey();
  if (currentreceivedkey_ == &::google::protobuf::internal::kEmptyString) {
    currentreceivedkey_ = new ::std::string;
  }
  return currentreceivedkey_;
}
inline ::std::string* contactDetail::release_currentreceivedkey() {
  clear_has_currentreceivedkey();
  if (currentreceivedkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentreceivedkey_;
    currentreceivedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void contactDetail::set_allocated_currentreceivedkey(::std::string* currentreceivedkey) {
  if (currentreceivedkey_ != &::google::protobuf::internal::kEmptyString) {
    delete currentreceivedkey_;
  }
  if (currentreceivedkey) {
    set_has_currentreceivedkey();
    currentreceivedkey_ = currentreceivedkey;
  } else {
    clear_has_currentreceivedkey();
    currentreceivedkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateReceivedKey = 7;
inline bool contactDetail::has_datereceivedkey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void contactDetail::set_has_datereceivedkey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void contactDetail::clear_has_datereceivedkey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void contactDetail::clear_datereceivedkey() {
  datereceivedkey_ = 0;
  clear_has_datereceivedkey();
}
inline ::google::protobuf::int32 contactDetail::datereceivedkey() const {
  return datereceivedkey_;
}
inline void contactDetail::set_datereceivedkey(::google::protobuf::int32 value) {
  set_has_datereceivedkey();
  datereceivedkey_ = value;
}

// optional int32 numberOfTimesContacted = 8;
inline bool contactDetail::has_numberoftimescontacted() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void contactDetail::set_has_numberoftimescontacted() {
  _has_bits_[0] |= 0x00000080u;
}
inline void contactDetail::clear_has_numberoftimescontacted() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void contactDetail::clear_numberoftimescontacted() {
  numberoftimescontacted_ = 0;
  clear_has_numberoftimescontacted();
}
inline ::google::protobuf::int32 contactDetail::numberoftimescontacted() const {
  return numberoftimescontacted_;
}
inline void contactDetail::set_numberoftimescontacted(::google::protobuf::int32 value) {
  set_has_numberoftimescontacted();
  numberoftimescontacted_ = value;
}

// optional int32 lastCheckedWithServer = 9;
inline bool contactDetail::has_lastcheckedwithserver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void contactDetail::set_has_lastcheckedwithserver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void contactDetail::clear_has_lastcheckedwithserver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void contactDetail::clear_lastcheckedwithserver() {
  lastcheckedwithserver_ = 0;
  clear_has_lastcheckedwithserver();
}
inline ::google::protobuf::int32 contactDetail::lastcheckedwithserver() const {
  return lastcheckedwithserver_;
}
inline void contactDetail::set_lastcheckedwithserver(::google::protobuf::int32 value) {
  set_has_lastcheckedwithserver();
  lastcheckedwithserver_ = value;
}

// optional string fullName = 10;
inline bool contactDetail::has_fullname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void contactDetail::set_has_fullname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void contactDetail::clear_has_fullname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void contactDetail::clear_fullname() {
  if (fullname_ != &::google::protobuf::internal::kEmptyString) {
    fullname_->clear();
  }
  clear_has_fullname();
}
inline const ::std::string& contactDetail::fullname() const {
  return *fullname_;
}
inline void contactDetail::set_fullname(const ::std::string& value) {
  set_has_fullname();
  if (fullname_ == &::google::protobuf::internal::kEmptyString) {
    fullname_ = new ::std::string;
  }
  fullname_->assign(value);
}
inline void contactDetail::set_fullname(const char* value) {
  set_has_fullname();
  if (fullname_ == &::google::protobuf::internal::kEmptyString) {
    fullname_ = new ::std::string;
  }
  fullname_->assign(value);
}
inline void contactDetail::set_fullname(const char* value, size_t size) {
  set_has_fullname();
  if (fullname_ == &::google::protobuf::internal::kEmptyString) {
    fullname_ = new ::std::string;
  }
  fullname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* contactDetail::mutable_fullname() {
  set_has_fullname();
  if (fullname_ == &::google::protobuf::internal::kEmptyString) {
    fullname_ = new ::std::string;
  }
  return fullname_;
}
inline ::std::string* contactDetail::release_fullname() {
  clear_has_fullname();
  if (fullname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fullname_;
    fullname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void contactDetail::set_allocated_fullname(::std::string* fullname) {
  if (fullname_ != &::google::protobuf::internal::kEmptyString) {
    delete fullname_;
  }
  if (fullname) {
    set_has_fullname();
    fullname_ = fullname;
  } else {
    clear_has_fullname();
    fullname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lastInfoChange = 11;
inline bool contactDetail::has_lastinfochange() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void contactDetail::set_has_lastinfochange() {
  _has_bits_[0] |= 0x00000400u;
}
inline void contactDetail::clear_has_lastinfochange() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void contactDetail::clear_lastinfochange() {
  lastinfochange_ = 0;
  clear_has_lastinfochange();
}
inline ::google::protobuf::int32 contactDetail::lastinfochange() const {
  return lastinfochange_;
}
inline void contactDetail::set_lastinfochange(::google::protobuf::int32 value) {
  set_has_lastinfochange();
  lastinfochange_ = value;
}

// -------------------------------------------------------------------

// syncKeyExpectation

// optional string fromAddress = 1;
inline bool syncKeyExpectation::has_fromaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syncKeyExpectation::set_has_fromaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syncKeyExpectation::clear_has_fromaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syncKeyExpectation::clear_fromaddress() {
  if (fromaddress_ != &::google::protobuf::internal::kEmptyString) {
    fromaddress_->clear();
  }
  clear_has_fromaddress();
}
inline const ::std::string& syncKeyExpectation::fromaddress() const {
  return *fromaddress_;
}
inline void syncKeyExpectation::set_fromaddress(const ::std::string& value) {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  fromaddress_->assign(value);
}
inline void syncKeyExpectation::set_fromaddress(const char* value) {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  fromaddress_->assign(value);
}
inline void syncKeyExpectation::set_fromaddress(const char* value, size_t size) {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  fromaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncKeyExpectation::mutable_fromaddress() {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  return fromaddress_;
}
inline ::std::string* syncKeyExpectation::release_fromaddress() {
  clear_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromaddress_;
    fromaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncKeyExpectation::set_allocated_fromaddress(::std::string* fromaddress) {
  if (fromaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete fromaddress_;
  }
  if (fromaddress) {
    set_has_fromaddress();
    fromaddress_ = fromaddress;
  } else {
    clear_has_fromaddress();
    fromaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string toAddress = 2;
inline bool syncKeyExpectation::has_toaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void syncKeyExpectation::set_has_toaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void syncKeyExpectation::clear_has_toaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void syncKeyExpectation::clear_toaddress() {
  if (toaddress_ != &::google::protobuf::internal::kEmptyString) {
    toaddress_->clear();
  }
  clear_has_toaddress();
}
inline const ::std::string& syncKeyExpectation::toaddress() const {
  return *toaddress_;
}
inline void syncKeyExpectation::set_toaddress(const ::std::string& value) {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  toaddress_->assign(value);
}
inline void syncKeyExpectation::set_toaddress(const char* value) {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  toaddress_->assign(value);
}
inline void syncKeyExpectation::set_toaddress(const char* value, size_t size) {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  toaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncKeyExpectation::mutable_toaddress() {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  return toaddress_;
}
inline ::std::string* syncKeyExpectation::release_toaddress() {
  clear_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toaddress_;
    toaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncKeyExpectation::set_allocated_toaddress(::std::string* toaddress) {
  if (toaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete toaddress_;
  }
  if (toaddress) {
    set_has_toaddress();
    toaddress_ = toaddress;
  } else {
    clear_has_toaddress();
    toaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string keyLabel = 3;
inline bool syncKeyExpectation::has_keylabel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void syncKeyExpectation::set_has_keylabel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void syncKeyExpectation::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void syncKeyExpectation::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& syncKeyExpectation::keylabel() const {
  return *keylabel_;
}
inline void syncKeyExpectation::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void syncKeyExpectation::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void syncKeyExpectation::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncKeyExpectation::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* syncKeyExpectation::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncKeyExpectation::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateAnchored = 4;
inline bool syncKeyExpectation::has_dateanchored() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void syncKeyExpectation::set_has_dateanchored() {
  _has_bits_[0] |= 0x00000008u;
}
inline void syncKeyExpectation::clear_has_dateanchored() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void syncKeyExpectation::clear_dateanchored() {
  dateanchored_ = 0;
  clear_has_dateanchored();
}
inline ::google::protobuf::int32 syncKeyExpectation::dateanchored() const {
  return dateanchored_;
}
inline void syncKeyExpectation::set_dateanchored(::google::protobuf::int32 value) {
  set_has_dateanchored();
  dateanchored_ = value;
}

// -------------------------------------------------------------------

// syncPrivateKey

// required bytes encrKeyData = 1;
inline bool syncPrivateKey::has_encrkeydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syncPrivateKey::set_has_encrkeydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syncPrivateKey::clear_has_encrkeydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syncPrivateKey::clear_encrkeydata() {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    encrkeydata_->clear();
  }
  clear_has_encrkeydata();
}
inline const ::std::string& syncPrivateKey::encrkeydata() const {
  return *encrkeydata_;
}
inline void syncPrivateKey::set_encrkeydata(const ::std::string& value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void syncPrivateKey::set_encrkeydata(const char* value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void syncPrivateKey::set_encrkeydata(const void* value, size_t size) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::mutable_encrkeydata() {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  return encrkeydata_;
}
inline ::std::string* syncPrivateKey::release_encrkeydata() {
  clear_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrkeydata_;
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPrivateKey::set_allocated_encrkeydata(::std::string* encrkeydata) {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrkeydata_;
  }
  if (encrkeydata) {
    set_has_encrkeydata();
    encrkeydata_ = encrkeydata;
  } else {
    clear_has_encrkeydata();
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes verKeyData = 2;
inline bool syncPrivateKey::has_verkeydata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void syncPrivateKey::set_has_verkeydata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void syncPrivateKey::clear_has_verkeydata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void syncPrivateKey::clear_verkeydata() {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    verkeydata_->clear();
  }
  clear_has_verkeydata();
}
inline const ::std::string& syncPrivateKey::verkeydata() const {
  return *verkeydata_;
}
inline void syncPrivateKey::set_verkeydata(const ::std::string& value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void syncPrivateKey::set_verkeydata(const char* value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void syncPrivateKey::set_verkeydata(const void* value, size_t size) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::mutable_verkeydata() {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  return verkeydata_;
}
inline ::std::string* syncPrivateKey::release_verkeydata() {
  clear_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verkeydata_;
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPrivateKey::set_allocated_verkeydata(::std::string* verkeydata) {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete verkeydata_;
  }
  if (verkeydata) {
    set_has_verkeydata();
    verkeydata_ = verkeydata;
  } else {
    clear_has_verkeydata();
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string keyLabel = 3;
inline bool syncPrivateKey::has_keylabel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void syncPrivateKey::set_has_keylabel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void syncPrivateKey::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void syncPrivateKey::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& syncPrivateKey::keylabel() const {
  return *keylabel_;
}
inline void syncPrivateKey::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void syncPrivateKey::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void syncPrivateKey::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* syncPrivateKey::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPrivateKey::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateCreated = 4;
inline bool syncPrivateKey::has_datecreated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void syncPrivateKey::set_has_datecreated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void syncPrivateKey::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void syncPrivateKey::clear_datecreated() {
  datecreated_ = 0;
  clear_has_datecreated();
}
inline ::google::protobuf::int32 syncPrivateKey::datecreated() const {
  return datecreated_;
}
inline void syncPrivateKey::set_datecreated(::google::protobuf::int32 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// optional bool isCompromised = 5;
inline bool syncPrivateKey::has_iscompromised() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void syncPrivateKey::set_has_iscompromised() {
  _has_bits_[0] |= 0x00000010u;
}
inline void syncPrivateKey::clear_has_iscompromised() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void syncPrivateKey::clear_iscompromised() {
  iscompromised_ = false;
  clear_has_iscompromised();
}
inline bool syncPrivateKey::iscompromised() const {
  return iscompromised_;
}
inline void syncPrivateKey::set_iscompromised(bool value) {
  set_has_iscompromised();
  iscompromised_ = value;
}

// optional string version = 6;
inline bool syncPrivateKey::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void syncPrivateKey::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void syncPrivateKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void syncPrivateKey::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& syncPrivateKey::version() const {
  return *version_;
}
inline void syncPrivateKey::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void syncPrivateKey::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void syncPrivateKey::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* syncPrivateKey::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPrivateKey::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string currentKeyForEmail = 7;
inline int syncPrivateKey::currentkeyforemail_size() const {
  return currentkeyforemail_.size();
}
inline void syncPrivateKey::clear_currentkeyforemail() {
  currentkeyforemail_.Clear();
}
inline const ::std::string& syncPrivateKey::currentkeyforemail(int index) const {
  return currentkeyforemail_.Get(index);
}
inline ::std::string* syncPrivateKey::mutable_currentkeyforemail(int index) {
  return currentkeyforemail_.Mutable(index);
}
inline void syncPrivateKey::set_currentkeyforemail(int index, const ::std::string& value) {
  currentkeyforemail_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_currentkeyforemail(int index, const char* value) {
  currentkeyforemail_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_currentkeyforemail(int index, const char* value, size_t size) {
  currentkeyforemail_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::add_currentkeyforemail() {
  return currentkeyforemail_.Add();
}
inline void syncPrivateKey::add_currentkeyforemail(const ::std::string& value) {
  currentkeyforemail_.Add()->assign(value);
}
inline void syncPrivateKey::add_currentkeyforemail(const char* value) {
  currentkeyforemail_.Add()->assign(value);
}
inline void syncPrivateKey::add_currentkeyforemail(const char* value, size_t size) {
  currentkeyforemail_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPrivateKey::currentkeyforemail() const {
  return currentkeyforemail_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPrivateKey::mutable_currentkeyforemail() {
  return &currentkeyforemail_;
}

// optional int32 dateObtained = 8;
inline bool syncPrivateKey::has_dateobtained() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void syncPrivateKey::set_has_dateobtained() {
  _has_bits_[0] |= 0x00000080u;
}
inline void syncPrivateKey::clear_has_dateobtained() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void syncPrivateKey::clear_dateobtained() {
  dateobtained_ = 0;
  clear_has_dateobtained();
}
inline ::google::protobuf::int32 syncPrivateKey::dateobtained() const {
  return dateobtained_;
}
inline void syncPrivateKey::set_dateobtained(::google::protobuf::int32 value) {
  set_has_dateobtained();
  dateobtained_ = value;
}

// optional int32 dateDeclared = 9;
inline bool syncPrivateKey::has_datedeclared() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void syncPrivateKey::set_has_datedeclared() {
  _has_bits_[0] |= 0x00000100u;
}
inline void syncPrivateKey::clear_has_datedeclared() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void syncPrivateKey::clear_datedeclared() {
  datedeclared_ = 0;
  clear_has_datedeclared();
}
inline ::google::protobuf::int32 syncPrivateKey::datedeclared() const {
  return datedeclared_;
}
inline void syncPrivateKey::set_datedeclared(::google::protobuf::int32 value) {
  set_has_datedeclared();
  datedeclared_ = value;
}

// optional int32 dateFirstAnchored = 10;
inline bool syncPrivateKey::has_datefirstanchored() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void syncPrivateKey::set_has_datefirstanchored() {
  _has_bits_[0] |= 0x00000200u;
}
inline void syncPrivateKey::clear_has_datefirstanchored() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void syncPrivateKey::clear_datefirstanchored() {
  datefirstanchored_ = 0;
  clear_has_datefirstanchored();
}
inline ::google::protobuf::int32 syncPrivateKey::datefirstanchored() const {
  return datefirstanchored_;
}
inline void syncPrivateKey::set_datefirstanchored(::google::protobuf::int32 value) {
  set_has_datefirstanchored();
  datefirstanchored_ = value;
}

// optional bool fromServer = 11;
inline bool syncPrivateKey::has_fromserver() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void syncPrivateKey::set_has_fromserver() {
  _has_bits_[0] |= 0x00000400u;
}
inline void syncPrivateKey::clear_has_fromserver() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void syncPrivateKey::clear_fromserver() {
  fromserver_ = false;
  clear_has_fromserver();
}
inline bool syncPrivateKey::fromserver() const {
  return fromserver_;
}
inline void syncPrivateKey::set_fromserver(bool value) {
  set_has_fromserver();
  fromserver_ = value;
}

// repeated string introducesKeys = 12;
inline int syncPrivateKey::introduceskeys_size() const {
  return introduceskeys_.size();
}
inline void syncPrivateKey::clear_introduceskeys() {
  introduceskeys_.Clear();
}
inline const ::std::string& syncPrivateKey::introduceskeys(int index) const {
  return introduceskeys_.Get(index);
}
inline ::std::string* syncPrivateKey::mutable_introduceskeys(int index) {
  return introduceskeys_.Mutable(index);
}
inline void syncPrivateKey::set_introduceskeys(int index, const ::std::string& value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_introduceskeys(int index, const char* value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_introduceskeys(int index, const char* value, size_t size) {
  introduceskeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::add_introduceskeys() {
  return introduceskeys_.Add();
}
inline void syncPrivateKey::add_introduceskeys(const ::std::string& value) {
  introduceskeys_.Add()->assign(value);
}
inline void syncPrivateKey::add_introduceskeys(const char* value) {
  introduceskeys_.Add()->assign(value);
}
inline void syncPrivateKey::add_introduceskeys(const char* value, size_t size) {
  introduceskeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPrivateKey::introduceskeys() const {
  return introduceskeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPrivateKey::mutable_introduceskeys() {
  return &introduceskeys_;
}

// repeated string isIntroducedByKeys = 13;
inline int syncPrivateKey::isintroducedbykeys_size() const {
  return isintroducedbykeys_.size();
}
inline void syncPrivateKey::clear_isintroducedbykeys() {
  isintroducedbykeys_.Clear();
}
inline const ::std::string& syncPrivateKey::isintroducedbykeys(int index) const {
  return isintroducedbykeys_.Get(index);
}
inline ::std::string* syncPrivateKey::mutable_isintroducedbykeys(int index) {
  return isintroducedbykeys_.Mutable(index);
}
inline void syncPrivateKey::set_isintroducedbykeys(int index, const ::std::string& value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_isintroducedbykeys(int index, const char* value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_isintroducedbykeys(int index, const char* value, size_t size) {
  isintroducedbykeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::add_isintroducedbykeys() {
  return isintroducedbykeys_.Add();
}
inline void syncPrivateKey::add_isintroducedbykeys(const ::std::string& value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void syncPrivateKey::add_isintroducedbykeys(const char* value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void syncPrivateKey::add_isintroducedbykeys(const char* value, size_t size) {
  isintroducedbykeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPrivateKey::isintroducedbykeys() const {
  return isintroducedbykeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPrivateKey::mutable_isintroducedbykeys() {
  return &isintroducedbykeys_;
}

// repeated string emailAddresses = 14;
inline int syncPrivateKey::emailaddresses_size() const {
  return emailaddresses_.size();
}
inline void syncPrivateKey::clear_emailaddresses() {
  emailaddresses_.Clear();
}
inline const ::std::string& syncPrivateKey::emailaddresses(int index) const {
  return emailaddresses_.Get(index);
}
inline ::std::string* syncPrivateKey::mutable_emailaddresses(int index) {
  return emailaddresses_.Mutable(index);
}
inline void syncPrivateKey::set_emailaddresses(int index, const ::std::string& value) {
  emailaddresses_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_emailaddresses(int index, const char* value) {
  emailaddresses_.Mutable(index)->assign(value);
}
inline void syncPrivateKey::set_emailaddresses(int index, const char* value, size_t size) {
  emailaddresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::add_emailaddresses() {
  return emailaddresses_.Add();
}
inline void syncPrivateKey::add_emailaddresses(const ::std::string& value) {
  emailaddresses_.Add()->assign(value);
}
inline void syncPrivateKey::add_emailaddresses(const char* value) {
  emailaddresses_.Add()->assign(value);
}
inline void syncPrivateKey::add_emailaddresses(const char* value, size_t size) {
  emailaddresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPrivateKey::emailaddresses() const {
  return emailaddresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPrivateKey::mutable_emailaddresses() {
  return &emailaddresses_;
}

// optional bytes decrKeyData = 15;
inline bool syncPrivateKey::has_decrkeydata() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void syncPrivateKey::set_has_decrkeydata() {
  _has_bits_[0] |= 0x00004000u;
}
inline void syncPrivateKey::clear_has_decrkeydata() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void syncPrivateKey::clear_decrkeydata() {
  if (decrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    decrkeydata_->clear();
  }
  clear_has_decrkeydata();
}
inline const ::std::string& syncPrivateKey::decrkeydata() const {
  return *decrkeydata_;
}
inline void syncPrivateKey::set_decrkeydata(const ::std::string& value) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(value);
}
inline void syncPrivateKey::set_decrkeydata(const char* value) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(value);
}
inline void syncPrivateKey::set_decrkeydata(const void* value, size_t size) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::mutable_decrkeydata() {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  return decrkeydata_;
}
inline ::std::string* syncPrivateKey::release_decrkeydata() {
  clear_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = decrkeydata_;
    decrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPrivateKey::set_allocated_decrkeydata(::std::string* decrkeydata) {
  if (decrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete decrkeydata_;
  }
  if (decrkeydata) {
    set_has_decrkeydata();
    decrkeydata_ = decrkeydata;
  } else {
    clear_has_decrkeydata();
    decrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signKeyData = 16;
inline bool syncPrivateKey::has_signkeydata() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void syncPrivateKey::set_has_signkeydata() {
  _has_bits_[0] |= 0x00008000u;
}
inline void syncPrivateKey::clear_has_signkeydata() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void syncPrivateKey::clear_signkeydata() {
  if (signkeydata_ != &::google::protobuf::internal::kEmptyString) {
    signkeydata_->clear();
  }
  clear_has_signkeydata();
}
inline const ::std::string& syncPrivateKey::signkeydata() const {
  return *signkeydata_;
}
inline void syncPrivateKey::set_signkeydata(const ::std::string& value) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(value);
}
inline void syncPrivateKey::set_signkeydata(const char* value) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(value);
}
inline void syncPrivateKey::set_signkeydata(const void* value, size_t size) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPrivateKey::mutable_signkeydata() {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  return signkeydata_;
}
inline ::std::string* syncPrivateKey::release_signkeydata() {
  clear_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signkeydata_;
    signkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPrivateKey::set_allocated_signkeydata(::std::string* signkeydata) {
  if (signkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete signkeydata_;
  }
  if (signkeydata) {
    set_has_signkeydata();
    signkeydata_ = signkeydata;
  } else {
    clear_has_signkeydata();
    signkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// syncPublicKey

// required bytes encrKeyData = 1;
inline bool syncPublicKey::has_encrkeydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syncPublicKey::set_has_encrkeydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syncPublicKey::clear_has_encrkeydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syncPublicKey::clear_encrkeydata() {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    encrkeydata_->clear();
  }
  clear_has_encrkeydata();
}
inline const ::std::string& syncPublicKey::encrkeydata() const {
  return *encrkeydata_;
}
inline void syncPublicKey::set_encrkeydata(const ::std::string& value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void syncPublicKey::set_encrkeydata(const char* value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void syncPublicKey::set_encrkeydata(const void* value, size_t size) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::mutable_encrkeydata() {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  return encrkeydata_;
}
inline ::std::string* syncPublicKey::release_encrkeydata() {
  clear_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrkeydata_;
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPublicKey::set_allocated_encrkeydata(::std::string* encrkeydata) {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrkeydata_;
  }
  if (encrkeydata) {
    set_has_encrkeydata();
    encrkeydata_ = encrkeydata;
  } else {
    clear_has_encrkeydata();
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes verKeyData = 2;
inline bool syncPublicKey::has_verkeydata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void syncPublicKey::set_has_verkeydata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void syncPublicKey::clear_has_verkeydata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void syncPublicKey::clear_verkeydata() {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    verkeydata_->clear();
  }
  clear_has_verkeydata();
}
inline const ::std::string& syncPublicKey::verkeydata() const {
  return *verkeydata_;
}
inline void syncPublicKey::set_verkeydata(const ::std::string& value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void syncPublicKey::set_verkeydata(const char* value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void syncPublicKey::set_verkeydata(const void* value, size_t size) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::mutable_verkeydata() {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  return verkeydata_;
}
inline ::std::string* syncPublicKey::release_verkeydata() {
  clear_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verkeydata_;
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPublicKey::set_allocated_verkeydata(::std::string* verkeydata) {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete verkeydata_;
  }
  if (verkeydata) {
    set_has_verkeydata();
    verkeydata_ = verkeydata;
  } else {
    clear_has_verkeydata();
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string keyLabel = 3;
inline bool syncPublicKey::has_keylabel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void syncPublicKey::set_has_keylabel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void syncPublicKey::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void syncPublicKey::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& syncPublicKey::keylabel() const {
  return *keylabel_;
}
inline void syncPublicKey::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void syncPublicKey::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void syncPublicKey::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* syncPublicKey::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPublicKey::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dateCreated = 4;
inline bool syncPublicKey::has_datecreated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void syncPublicKey::set_has_datecreated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void syncPublicKey::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void syncPublicKey::clear_datecreated() {
  datecreated_ = 0;
  clear_has_datecreated();
}
inline ::google::protobuf::int32 syncPublicKey::datecreated() const {
  return datecreated_;
}
inline void syncPublicKey::set_datecreated(::google::protobuf::int32 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// optional bool compromised = 5;
inline bool syncPublicKey::has_compromised() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void syncPublicKey::set_has_compromised() {
  _has_bits_[0] |= 0x00000010u;
}
inline void syncPublicKey::clear_has_compromised() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void syncPublicKey::clear_compromised() {
  compromised_ = false;
  clear_has_compromised();
}
inline bool syncPublicKey::compromised() const {
  return compromised_;
}
inline void syncPublicKey::set_compromised(bool value) {
  set_has_compromised();
  compromised_ = value;
}

// optional string version = 6;
inline bool syncPublicKey::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void syncPublicKey::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void syncPublicKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void syncPublicKey::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& syncPublicKey::version() const {
  return *version_;
}
inline void syncPublicKey::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void syncPublicKey::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void syncPublicKey::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* syncPublicKey::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void syncPublicKey::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string currentKeyForEmail = 7;
inline int syncPublicKey::currentkeyforemail_size() const {
  return currentkeyforemail_.size();
}
inline void syncPublicKey::clear_currentkeyforemail() {
  currentkeyforemail_.Clear();
}
inline const ::std::string& syncPublicKey::currentkeyforemail(int index) const {
  return currentkeyforemail_.Get(index);
}
inline ::std::string* syncPublicKey::mutable_currentkeyforemail(int index) {
  return currentkeyforemail_.Mutable(index);
}
inline void syncPublicKey::set_currentkeyforemail(int index, const ::std::string& value) {
  currentkeyforemail_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_currentkeyforemail(int index, const char* value) {
  currentkeyforemail_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_currentkeyforemail(int index, const char* value, size_t size) {
  currentkeyforemail_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::add_currentkeyforemail() {
  return currentkeyforemail_.Add();
}
inline void syncPublicKey::add_currentkeyforemail(const ::std::string& value) {
  currentkeyforemail_.Add()->assign(value);
}
inline void syncPublicKey::add_currentkeyforemail(const char* value) {
  currentkeyforemail_.Add()->assign(value);
}
inline void syncPublicKey::add_currentkeyforemail(const char* value, size_t size) {
  currentkeyforemail_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPublicKey::currentkeyforemail() const {
  return currentkeyforemail_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPublicKey::mutable_currentkeyforemail() {
  return &currentkeyforemail_;
}

// optional int32 dateObtained = 8;
inline bool syncPublicKey::has_dateobtained() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void syncPublicKey::set_has_dateobtained() {
  _has_bits_[0] |= 0x00000080u;
}
inline void syncPublicKey::clear_has_dateobtained() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void syncPublicKey::clear_dateobtained() {
  dateobtained_ = 0;
  clear_has_dateobtained();
}
inline ::google::protobuf::int32 syncPublicKey::dateobtained() const {
  return dateobtained_;
}
inline void syncPublicKey::set_dateobtained(::google::protobuf::int32 value) {
  set_has_dateobtained();
  dateobtained_ = value;
}

// optional int32 dateDeclared = 9;
inline bool syncPublicKey::has_datedeclared() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void syncPublicKey::set_has_datedeclared() {
  _has_bits_[0] |= 0x00000100u;
}
inline void syncPublicKey::clear_has_datedeclared() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void syncPublicKey::clear_datedeclared() {
  datedeclared_ = 0;
  clear_has_datedeclared();
}
inline ::google::protobuf::int32 syncPublicKey::datedeclared() const {
  return datedeclared_;
}
inline void syncPublicKey::set_datedeclared(::google::protobuf::int32 value) {
  set_has_datedeclared();
  datedeclared_ = value;
}

// optional int32 dateFirstAnchored = 10;
inline bool syncPublicKey::has_datefirstanchored() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void syncPublicKey::set_has_datefirstanchored() {
  _has_bits_[0] |= 0x00000200u;
}
inline void syncPublicKey::clear_has_datefirstanchored() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void syncPublicKey::clear_datefirstanchored() {
  datefirstanchored_ = 0;
  clear_has_datefirstanchored();
}
inline ::google::protobuf::int32 syncPublicKey::datefirstanchored() const {
  return datefirstanchored_;
}
inline void syncPublicKey::set_datefirstanchored(::google::protobuf::int32 value) {
  set_has_datefirstanchored();
  datefirstanchored_ = value;
}

// optional bool fromServer = 11;
inline bool syncPublicKey::has_fromserver() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void syncPublicKey::set_has_fromserver() {
  _has_bits_[0] |= 0x00000400u;
}
inline void syncPublicKey::clear_has_fromserver() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void syncPublicKey::clear_fromserver() {
  fromserver_ = false;
  clear_has_fromserver();
}
inline bool syncPublicKey::fromserver() const {
  return fromserver_;
}
inline void syncPublicKey::set_fromserver(bool value) {
  set_has_fromserver();
  fromserver_ = value;
}

// repeated string introducesKeys = 12;
inline int syncPublicKey::introduceskeys_size() const {
  return introduceskeys_.size();
}
inline void syncPublicKey::clear_introduceskeys() {
  introduceskeys_.Clear();
}
inline const ::std::string& syncPublicKey::introduceskeys(int index) const {
  return introduceskeys_.Get(index);
}
inline ::std::string* syncPublicKey::mutable_introduceskeys(int index) {
  return introduceskeys_.Mutable(index);
}
inline void syncPublicKey::set_introduceskeys(int index, const ::std::string& value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_introduceskeys(int index, const char* value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_introduceskeys(int index, const char* value, size_t size) {
  introduceskeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::add_introduceskeys() {
  return introduceskeys_.Add();
}
inline void syncPublicKey::add_introduceskeys(const ::std::string& value) {
  introduceskeys_.Add()->assign(value);
}
inline void syncPublicKey::add_introduceskeys(const char* value) {
  introduceskeys_.Add()->assign(value);
}
inline void syncPublicKey::add_introduceskeys(const char* value, size_t size) {
  introduceskeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPublicKey::introduceskeys() const {
  return introduceskeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPublicKey::mutable_introduceskeys() {
  return &introduceskeys_;
}

// repeated string isIntroducedByKeys = 13;
inline int syncPublicKey::isintroducedbykeys_size() const {
  return isintroducedbykeys_.size();
}
inline void syncPublicKey::clear_isintroducedbykeys() {
  isintroducedbykeys_.Clear();
}
inline const ::std::string& syncPublicKey::isintroducedbykeys(int index) const {
  return isintroducedbykeys_.Get(index);
}
inline ::std::string* syncPublicKey::mutable_isintroducedbykeys(int index) {
  return isintroducedbykeys_.Mutable(index);
}
inline void syncPublicKey::set_isintroducedbykeys(int index, const ::std::string& value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_isintroducedbykeys(int index, const char* value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_isintroducedbykeys(int index, const char* value, size_t size) {
  isintroducedbykeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::add_isintroducedbykeys() {
  return isintroducedbykeys_.Add();
}
inline void syncPublicKey::add_isintroducedbykeys(const ::std::string& value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void syncPublicKey::add_isintroducedbykeys(const char* value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void syncPublicKey::add_isintroducedbykeys(const char* value, size_t size) {
  isintroducedbykeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPublicKey::isintroducedbykeys() const {
  return isintroducedbykeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPublicKey::mutable_isintroducedbykeys() {
  return &isintroducedbykeys_;
}

// repeated string emailAddresses = 14;
inline int syncPublicKey::emailaddresses_size() const {
  return emailaddresses_.size();
}
inline void syncPublicKey::clear_emailaddresses() {
  emailaddresses_.Clear();
}
inline const ::std::string& syncPublicKey::emailaddresses(int index) const {
  return emailaddresses_.Get(index);
}
inline ::std::string* syncPublicKey::mutable_emailaddresses(int index) {
  return emailaddresses_.Mutable(index);
}
inline void syncPublicKey::set_emailaddresses(int index, const ::std::string& value) {
  emailaddresses_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_emailaddresses(int index, const char* value) {
  emailaddresses_.Mutable(index)->assign(value);
}
inline void syncPublicKey::set_emailaddresses(int index, const char* value, size_t size) {
  emailaddresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* syncPublicKey::add_emailaddresses() {
  return emailaddresses_.Add();
}
inline void syncPublicKey::add_emailaddresses(const ::std::string& value) {
  emailaddresses_.Add()->assign(value);
}
inline void syncPublicKey::add_emailaddresses(const char* value) {
  emailaddresses_.Add()->assign(value);
}
inline void syncPublicKey::add_emailaddresses(const char* value, size_t size) {
  emailaddresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
syncPublicKey::emailaddresses() const {
  return emailaddresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
syncPublicKey::mutable_emailaddresses() {
  return &emailaddresses_;
}

// -------------------------------------------------------------------

// syncData

// repeated .mynigma.syncPrivateKey privKeys = 1;
inline int syncData::privkeys_size() const {
  return privkeys_.size();
}
inline void syncData::clear_privkeys() {
  privkeys_.Clear();
}
inline const ::mynigma::syncPrivateKey& syncData::privkeys(int index) const {
  return privkeys_.Get(index);
}
inline ::mynigma::syncPrivateKey* syncData::mutable_privkeys(int index) {
  return privkeys_.Mutable(index);
}
inline ::mynigma::syncPrivateKey* syncData::add_privkeys() {
  return privkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::syncPrivateKey >&
syncData::privkeys() const {
  return privkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::syncPrivateKey >*
syncData::mutable_privkeys() {
  return &privkeys_;
}

// repeated .mynigma.syncPublicKey pubKeys = 2;
inline int syncData::pubkeys_size() const {
  return pubkeys_.size();
}
inline void syncData::clear_pubkeys() {
  pubkeys_.Clear();
}
inline const ::mynigma::syncPublicKey& syncData::pubkeys(int index) const {
  return pubkeys_.Get(index);
}
inline ::mynigma::syncPublicKey* syncData::mutable_pubkeys(int index) {
  return pubkeys_.Mutable(index);
}
inline ::mynigma::syncPublicKey* syncData::add_pubkeys() {
  return pubkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::syncPublicKey >&
syncData::pubkeys() const {
  return pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::syncPublicKey >*
syncData::mutable_pubkeys() {
  return &pubkeys_;
}

// repeated .mynigma.accountLoginData accounts = 3;
inline int syncData::accounts_size() const {
  return accounts_.size();
}
inline void syncData::clear_accounts() {
  accounts_.Clear();
}
inline const ::mynigma::accountLoginData& syncData::accounts(int index) const {
  return accounts_.Get(index);
}
inline ::mynigma::accountLoginData* syncData::mutable_accounts(int index) {
  return accounts_.Mutable(index);
}
inline ::mynigma::accountLoginData* syncData::add_accounts() {
  return accounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >&
syncData::accounts() const {
  return accounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::accountLoginData >*
syncData::mutable_accounts() {
  return &accounts_;
}

// repeated .mynigma.contactDetail contacts = 4;
inline int syncData::contacts_size() const {
  return contacts_.size();
}
inline void syncData::clear_contacts() {
  contacts_.Clear();
}
inline const ::mynigma::contactDetail& syncData::contacts(int index) const {
  return contacts_.Get(index);
}
inline ::mynigma::contactDetail* syncData::mutable_contacts(int index) {
  return contacts_.Mutable(index);
}
inline ::mynigma::contactDetail* syncData::add_contacts() {
  return contacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::contactDetail >&
syncData::contacts() const {
  return contacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::contactDetail >*
syncData::mutable_contacts() {
  return &contacts_;
}

// repeated .mynigma.syncKeyExpectation keyExpectations = 5;
inline int syncData::keyexpectations_size() const {
  return keyexpectations_.size();
}
inline void syncData::clear_keyexpectations() {
  keyexpectations_.Clear();
}
inline const ::mynigma::syncKeyExpectation& syncData::keyexpectations(int index) const {
  return keyexpectations_.Get(index);
}
inline ::mynigma::syncKeyExpectation* syncData::mutable_keyexpectations(int index) {
  return keyexpectations_.Mutable(index);
}
inline ::mynigma::syncKeyExpectation* syncData::add_keyexpectations() {
  return keyexpectations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::syncKeyExpectation >&
syncData::keyexpectations() const {
  return keyexpectations_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::syncKeyExpectation >*
syncData::mutable_keyexpectations() {
  return &keyexpectations_;
}

// -------------------------------------------------------------------

// deviceDiscoveryData

// optional string UUID = 1;
inline bool deviceDiscoveryData::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void deviceDiscoveryData::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void deviceDiscoveryData::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void deviceDiscoveryData::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& deviceDiscoveryData::uuid() const {
  return *uuid_;
}
inline void deviceDiscoveryData::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void deviceDiscoveryData::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void deviceDiscoveryData::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryData::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* deviceDiscoveryData::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryData::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool deviceDiscoveryData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void deviceDiscoveryData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void deviceDiscoveryData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void deviceDiscoveryData::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& deviceDiscoveryData::type() const {
  return *type_;
}
inline void deviceDiscoveryData::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void deviceDiscoveryData::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void deviceDiscoveryData::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryData::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* deviceDiscoveryData::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryData::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool deviceDiscoveryData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void deviceDiscoveryData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void deviceDiscoveryData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void deviceDiscoveryData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& deviceDiscoveryData::name() const {
  return *name_;
}
inline void deviceDiscoveryData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void deviceDiscoveryData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void deviceDiscoveryData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* deviceDiscoveryData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string emailAdresses = 4;
inline int deviceDiscoveryData::emailadresses_size() const {
  return emailadresses_.size();
}
inline void deviceDiscoveryData::clear_emailadresses() {
  emailadresses_.Clear();
}
inline const ::std::string& deviceDiscoveryData::emailadresses(int index) const {
  return emailadresses_.Get(index);
}
inline ::std::string* deviceDiscoveryData::mutable_emailadresses(int index) {
  return emailadresses_.Mutable(index);
}
inline void deviceDiscoveryData::set_emailadresses(int index, const ::std::string& value) {
  emailadresses_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryData::set_emailadresses(int index, const char* value) {
  emailadresses_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryData::set_emailadresses(int index, const char* value, size_t size) {
  emailadresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryData::add_emailadresses() {
  return emailadresses_.Add();
}
inline void deviceDiscoveryData::add_emailadresses(const ::std::string& value) {
  emailadresses_.Add()->assign(value);
}
inline void deviceDiscoveryData::add_emailadresses(const char* value) {
  emailadresses_.Add()->assign(value);
}
inline void deviceDiscoveryData::add_emailadresses(const char* value, size_t size) {
  emailadresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
deviceDiscoveryData::emailadresses() const {
  return emailadresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
deviceDiscoveryData::mutable_emailadresses() {
  return &emailadresses_;
}

// repeated string privateKeyLabels = 5;
inline int deviceDiscoveryData::privatekeylabels_size() const {
  return privatekeylabels_.size();
}
inline void deviceDiscoveryData::clear_privatekeylabels() {
  privatekeylabels_.Clear();
}
inline const ::std::string& deviceDiscoveryData::privatekeylabels(int index) const {
  return privatekeylabels_.Get(index);
}
inline ::std::string* deviceDiscoveryData::mutable_privatekeylabels(int index) {
  return privatekeylabels_.Mutable(index);
}
inline void deviceDiscoveryData::set_privatekeylabels(int index, const ::std::string& value) {
  privatekeylabels_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryData::set_privatekeylabels(int index, const char* value) {
  privatekeylabels_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryData::set_privatekeylabels(int index, const char* value, size_t size) {
  privatekeylabels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryData::add_privatekeylabels() {
  return privatekeylabels_.Add();
}
inline void deviceDiscoveryData::add_privatekeylabels(const ::std::string& value) {
  privatekeylabels_.Add()->assign(value);
}
inline void deviceDiscoveryData::add_privatekeylabels(const char* value) {
  privatekeylabels_.Add()->assign(value);
}
inline void deviceDiscoveryData::add_privatekeylabels(const char* value, size_t size) {
  privatekeylabels_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
deviceDiscoveryData::privatekeylabels() const {
  return privatekeylabels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
deviceDiscoveryData::mutable_privatekeylabels() {
  return &privatekeylabels_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mynigma

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_syncData_2eproto__INCLUDED
